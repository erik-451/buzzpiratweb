[{"body":"The bitbang protocol uses a single byte for all commands. The default start-up state is pin input (HiZ).\nSend 0x00 to the user terminal (max.) 20 times to enter the raw binary bitbang mode. Check in between if BBIO1 is returned. Send 0x0F to exit raw bitbang mode and reset the Buzzpirat. Other raw protocol modes are accessible from within bitbang mode, 0x00 always returns to raw bitbang mode and prints the version string. There is a slight settling delay between pin updates, currently about 5us. Warning To avoid the BBIO1 endless loop bug in the Buzzpirat, it is crucial to send each 0x00 command individually and verify the presence of a “BBIO1” response. Transmitting multiple 0x00 commands rapidly in succession may lead to a continuous BBIO1 response loop. The sole solution to this loop issue is to disconnect and then reconnect the USB: http://dangerousprototypes.com/forum/index.php?topic=4227.0 MAIN b00000000 (0x00) - Reset, responds “BBIO1” MAIN b00000001 (0x01) - Enter binary SPI mode, responds “SPI1” SPI Mode, Key points SPI b00000001 (0x01) - Enter raw SPI mode, display version string SPI b0000001x (0x02-0x03) - CS high (1) or low (0) SPI b000011xx (0x0C-0x0F) - Sniff SPI traffic when CS low(10)/all(01) SPI b0001xxxx (0x10-0x1F) - Bulk SPI transfer, send/read 1-16 bytes (0=1byte!) SPI b0100wxyz (0x40-0x4F) - Configure peripherals w=power, x=pull-ups, y=AUX, z=CS SPI b01100xxx (0x60-0x67) - SPI speed SPI b1000wxyz (0x80-0x8F) - SPI config, w=HiZ/3.3v, x=CKP idle, y=CKE edge, z=SMP sample SPI b00000100 (0x04) - Write then read \u0026 b00000101 (0x05) - Write then read, no CS SPI b00000110 (0x06) - AVR Extended Commands SPI b11111110 (0xFE) - Execute Buzz Commands MAIN b00000010 (0x02) - Enter binary I2C mode, responds “I2C1” I2C Mode, Key points I2C b00000001 (0x01) – Display mode version string, responds “I2C1” I2C b00000010 (0x02) – I2C start bit I2C b00000011 (0x03) - I2C stop bit I2C b00000100 (0x04) - I2C Read Byte I2C b00000110 (0x06) - ACK bit I2C b00000111 (0x07) - NACK bit I2C b00001111 (0x0F) - Start bus sniffer I2C b0001xxxx (0x10-0x1F) – Bulk I2C write, send 1-16 bytes (0=1byte!) I2C b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS I2C b011000xx (0x60-0x63) - Set I2C speed, 3=~400kHz, 2=~100kHz, 1=~50kHz, 0=~5kHz I2C b00001000 (0x08) - Write then read I2C b00001001 (0x09) Extended AUX command I2C b11111110 (0xFE) - Execute Buzz Commands MAIN b00000011 (0x03) - Enter binary UART mode, responds “ART1” UART Mode, Key points UART b00000001 (0x01) – Display mode version string, responds “ART1” UART b0000001x (0x02-0x03) – Start (0)/stop(1) echo UART RX UART b00000111 (0x07) – Manual baud rate configuration, send 2 bytes UART b00001111 (0x0F) - UART bridge mode (reset to exit) UART b0001xxxx (0x10-0x1F) – Bulk UART write, send 1-16 bytes (0=1byte!) UART b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS UART b011000xx (0x60-0x63) - Set UART speed UART b100wxxyz (0x80-0x9F) – Configure UART settings UART b11111110 (0xFE) - Execute Buzz Commands MAIN b00000100 (0x04) - Enter binary 1-Wire mode, responds “1W01” 1-Wire Mode, Key points 1-Wire b00000001 (0x01) – Display mode version string, responds “1W01” 1-Wire b00000010 (0x02) – 1-Wire reset 1-Wire b00000100 (0x04) – Read byte 1-Wire b00001000 (0x08) - ROM search macro (0xF0) 1-Wire b00001001 (0x09) - ALARM search macro (0xEC) 1-Wire b0001xxxx (0x10-0x1F) – Bulk 1-Wire write, send 1-16 bytes (0=1byte!) 1-Wire b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS 1-Wire b11111110 (0xFE) - Execute Buzz Commands MAIN b00000101 (0x05) - Enter binary RAW-WIRE mode, responds “RAW1” RAW-WIRE Mode, Key points RAW-WIRE b00000001 (0x01) – Display mode version string, responds “RAW1” RAW-WIRE b0000001x (0x02-0x03) - I2C-style start (0) / stop (1) bit RAW-WIRE b0000010x (0x04-0x05) - CS low (0) / high (1) RAW-WIRE b00000110 (0x06) - Read byte RAW-WIRE b00000111 (0x07) - Read bit RAW-WIRE b00001000 (0x08) - Peek at input pin RAW-WIRE b00001001 (0x09) - Clock Tick RAW-WIRE b0000101x (0x0A-0x0B) - Clock low (0) / high (1) RAW-WIRE b0000110x (0x0C-0x0D) - Data low (0) / high (1) RAW-WIRE b0001xxxx (0x10-0x1F) – Bulk transfer, send 1-16 bytes (0=1byte!) RAW-WIRE b0010xxxx (0x20-0x2F) - Bulk clock ticks, send 1-16 ticks RAW-WIRE b0011xxxx (0x30-0x3F) - Bulk bits, send 1-8 bits of the next byte (0=1bit!) RAW-WIRE b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS RAW-WIRE b011000xx (0x60-0x63) - Set bus speed, 3=~400kHz, 2=~100kHz, 1=~50kHz, 0=~5kHz RAW-WIRE b1000wxyz (0x80-0x8F) – Config, w=HiZ/3.3v, x=2/3wire, y=msb/lsb, z=not used RAW-WIRE b10100100 (0xA4) - PIC write. Send command + 2 bytes of data, read 1 byte RAW-WIRE b10100101 (0xA5) - PIC read. Send command, read 1 byte of data RAW-WIRE b11111110 (0xFE) - Execute Buzz Commands MAIN b00000110 (0x06) - Enter OpenOCD JTAG mode MAIN b00001010 (0x0A) - Enter Buzz mode Buzz b01101001 (0x69) - NULL COMMAND Buzz b10010110 (0x96) - Check if firmware is BPv3 Buzz b00000000 (0x00) - Take voltage measurement from all sources Buzz b00000001 (0x01) - TP0 INPUT LOW Buzz b00000010 (0x02) - TP0 OUTPUT LOW Buzz b00000011 (0x03) - Read TP0 status Buzz b00010000 (0x10) - Check for short circuits in the power supply units Buzz b00010010 (0x12) - Setup pulse-width modulation (requires 5 byte setup) Buzz b00010011 (0x13) - Clear/disable PWM Buzz b00010100 (0x14) - Take voltage probe measurement (returns 2 bytes) Buzz b00010101 (0x15) - Continuous voltage probe measurement Buzz b00010110 (0x16) - Frequency measurement on AUX pin MAIN b00001111 (0x0F) - Reset Buzzpirat MAIN b00010000 (0x10) - Buzzpirat Short self-test \u0026 b00010001 (0x11) Long self-test MAIN b00010010 (0x12) - Setup pulse-width modulation (requires 5 byte setup) MAIN b00010011 (0x13) - Clear/disable PWM MAIN b00010100 (0x14) - Take voltage probe measurement (returns 2 bytes) MAIN b00010101 (0x15) - Continuous voltage probe measurement MAIN b00010110 (0x16) - Frequency measurement on AUX pin MAIN b010xxxxx (0x40-0x5F) - Configure pins as input(1) or output(0): AUX|MOSI|CLK|MISO|CS MAIN b1xxxxxxx (0x80-0xFF) - Set on (1) or off (0): POWER|PULLUP|AUX|MOSI|CLK|MISO|CS ADC Calculation Python 3 C PWM Computation Python 3 C MAIN b00000000 (0x00) - Reset, responds “BBIO1” This command resets the Buzzpirat into raw bitbang mode from the user terminal. It also resets to raw bitbang mode from raw SPI mode, or any other protocol mode. This command always returns a five byte bitbang version string “BBIO1”, where 1 is the current protocol version.\nSome terminals send a NULL character (0x00) on start-up, causing the Buzzpirat to enter binary mode when it wasn’t wanted. To get around this, you must now enter 0x00 at least 20 times to enter raw bitbang mode.\nWarning The Buzzpirat user terminal could be stuck in a configuration menu when your program attempts to enter binary mode. One way to ensure that you’re at the command line is to send at least 10 times, and then send ‘#’ to reset. Next, send 0x00 to the command line 20+ times until you get the BBIO1 string. After entering bitbang mode, you can enter other binary protocol modes.\nMAIN b00000001 (0x01) - Enter binary SPI mode, responds “SPI1” Commands are a single byte, except bulk SPI transfers. The Buzzpirat responds to SPI write commands with the data read from the SPI bus during the write. Most other commands return 0x01 for success, or 0x00 for failure/unknown command.\nSPI Mode, Key points Send 0x00 to the user terminal (max.) 20 times to enter the raw binary bitbang mode. Pause briefly after sending each 0x00 to check if BBIO1 is returned. Example binary mode entry functions. Enter 0x01 in bitbang mode to enter raw SPI mode. Return to raw bitbang mode from raw SPI mode by sending 0x00 one time. Operations that write a byte to the SPI bus also return a byte read from the SPI bus. Hex values shown here, like 0x00, represent actual byte values; not typed ASCII entered into a terminal. Once you have successfully entered the mode, you can use the following commands:\nSPI b00000001 (0x01) - Enter raw SPI mode, display version string Once in raw bitbang mode, send 0x01 to enter raw SPI mode. The Buzzpirat responds ‘SPI1’, where 1 is the raw SPI protocol version. Get the version string at any time by sending 0x01 again.\nSPI b0000001x (0x02-0x03) - CS high (1) or low (0) Toggle the Buzzpirat chip select pin, follows HiZ configuration setting. CS high is pin output at 3.3volts, or HiZ. CS low is pin output at ground. Buzzpirat responds 0x01.\nSPI b000011xx (0x0C-0x0F) - Sniff SPI traffic when CS low(10)/all(01) The SPI sniffer is implemented in hardware and should work up to 10MHz. It follows the configuration settings you entered for SPI mode. The sniffer can read all traffic, or filter by the state of the CS pin.\n[/] - CS enable/disable \\xy - escape character (\\) precedes two byte values X (MOSI pin) and Y (MISO pin) Sniffed traffic is encoded according to the table above. The two data bytes are escaped with the ‘' character to help locate data in the stream.\nSend the SPI sniffer command to start the sniffer, the Buzzpirat responds 0x01 then sniffed data starts to flow. Send any byte to exit.\nIf the sniffer can’t keep with the SPI data, the MODE LED turns off and the sniff is aborted.\nThe sniffer follows the output clock edge and output polarity settings of the SPI mode, but not the input sample phase.\nSPI b0001xxxx (0x10-0x1F) - Bulk SPI transfer, send/read 1-16 bytes (0=1byte!) Bulk SPI allows direct byte reads and writes. The Buzzpirat expects xxxx+1 data bytes. Up to 16 data bytes can be sent at once, each returns a byte read from the SPI bus during the write.\nNote that 0000 indicates 1 byte because there’s no reason to send 0. BP replies 0x01 to the bulk SPI command, and returns the value read from SPI after each data byte write.\nThe way it goes together:\nThe upper 4 bit of the command byte are the bulk read command (0001xxxx) xxxx = the number of bytes to read. 0000=1, 0001=2, etc, up to 1111=16 If I want to read (0001) four bytes (0011=3=read 4) the full command is 00010011 (0001 + 0011 ). Convert from binary to hex and it is 0x13\nSPI b0100wxyz (0x40-0x4F) - Configure peripherals w=power, x=pull-ups, y=AUX, z=CS Enable (1) and disable (0) Buzzpirat peripherals and pins. Bit w enables the power supplies, bit x toggles the on-board pull-up resistors, y sets the state of the auxiliary pin, and z sets the chip select pin. Features not present in a specific hardware version are ignored. Buzzpirat responds 0x01 on success.\nNote CS pin always follows the current HiZ pin configuration. AUX is always a normal pin output (0=GND, 1=3.3volts) SPI b01100xxx (0x60-0x67) - SPI speed 000=30kHz, 001=125kHz, 010=250kHz, 011=1MHz, 100=2MHz, 101=2.6MHz, 110=4MHz, 111=8MHz\nThis command sets the SPI bus speed according to the values shown. Default startup speed is 000 (30kHz).\nSPI b1000wxyz (0x80-0x8F) - SPI config, w=HiZ/3.3v, x=CKP idle, y=CKE edge, z=SMP sample This command configures the SPI settings. Options and start-up defaults are the same as the user terminal SPI mode. w= pin output HiZ(0)/3.3v(1), x=CKP clock idle phase (low=0), y=CKE clock edge (active to idle=1), z=SMP sample time (middle=0). The Buzzpirat responds 0x01 on success.\nDefault raw SPI startup condition is 0010. HiZ mode configuration applies to the SPI pins and the CS pin, but not the AUX pin. See the PIC24FJ64GA002 datasheet and the SPI section of the PIC24 family manual for more about the SPI configuration settings.\nSPI b00000100 (0x04) - Write then read \u0026 b00000101 (0x05) - Write then read, no CS This command was developed to help speed ROM programming with Flashrom, asprogrammer dreg mod. It might be helpful for a lot of common SPI operations.\nb00000100 - Write then read: It enables chip select, writes 0-4096 bytes, reads 0-4096 bytes, then disables chip select. b00000101 - Write then read, no CS: writes 0-4096 bytes, reads 0-4096 bytes (CS transitions are NOT automated/included). All data for this command can be sent at once, and it will be buffered in the Buzzpirat. The write and read operations happen all at once, and the read data is buffered. At the end of the operation, the read data is returned from the buffer. The goal is to meet the stringent timing requirements of some ROM chips by buffering everything instead of letting the serial port delay things.\nWrite then read command format:\nsend 1 byte: b00000100 (Write then read command) or b00000101 (Write then read, no CS) send 2 bytes: number of write bytes 0-4096 (first byte High8, second Low8) send 2 bytes: number of read bytes 0-4096 (first byte High8, second Low8) If the number of bytes to read or write are out of bounds, the Buzzpirat will send 0x00 now send 0-4096 bytes: bytes to write (specified by step 2) read 1 byte: success/0x01 read 0-4096 bytes: bytes to read (specified by step 3) Key Points:\nThere is no acknowledgment that a byte is received. All write bytes are sent at once (before that CS goes low for b00000100 - Write then read command) Read starts immediately, all bytes are put into a buffer at max SPI speed (no waiting for UART) At the end of the read, CS goes high for b00000100 - Write then read command SPI b00000110 (0x06) - AVR Extended Commands b00000000 (0x00) - Null operation - verifies extended commands are available. b00000001 (0x01) - Return version (2 bytes) b00000010 (0x02) - Bulk Memory Read from Flash SPI b11111110 (0xFE) - Execute Buzz Commands Buzz Commands allows for actions such as reading all voltages (similar to the ‘v’ command), manipulating the TP0 pin, etc.\nYou have access to the same commands as when you enter Buzz Mode using 0x0A. A list of the supported commands is available further below.\nBuzzpirat returns 0x01 if it has successfully entered this mode.\nSPI Buzz Commands (0x97-0xFF) Each protocol has reserved the range from 0x97 to 0xFF for protocol-specific Buzz commands. However, none have been defined for this protocol yet.\nMAIN b00000010 (0x02) - Enter binary I2C mode, responds “I2C1” Enter binary I2C mode by first entering bitbang mode, then send 0x02 to enter I2C mode.\nMost I2C mode commands are a single byte. Commands generally return 1 for success, 0 for failure.\nI2C Mode, Key points Send 0x00 to the user terminal (max.) 20 times to enter the raw binary bitbang mode. Pause briefly after sending each 0x00 to check if BBIO1 is returned. Example binary mode entry functions. Enter 0x02 in bitbang mode to enter raw I2C mode. Return to raw bitbang mode from raw I2C mode by sending 0x00 one time. Hex values shown here, like 0x00, represent actual byte values; not typed ASCII entered into a terminal. Once you have successfully entered the mode, you can use the following commands:\nI2C b00000001 (0x01) – Display mode version string, responds “I2C1” Once in binary I2C mode, send 0x01 to get the current mode version string. The Buzzpirat responds ‘I2C1’, where x is the raw I2C protocol version (currently 1). Get the version string at any time by sending 0x01 again. This command is the same in all binary modes, the current mode can always be determined by sending 0x01.\nI2C b00000010 (0x02) – I2C start bit Send an I2C start bit. Responds 0x01.\nI2C b00000011 (0x03) - I2C stop bit Send an I2C stop bit. Responds 0x01.\nI2C b00000100 (0x04) - I2C Read Byte Reads a byte from the I2C bus and returns the byte. You must manually ACK or NACK each byte!\nI2C b00000110 (0x06) - ACK bit Send an I2C ACK bit after reading a byte. Tells a slave device that you will read another byte. Responds 0x01.\nI2C b00000111 (0x07) - NACK bit Send an I2C NACK bit after reading a byte. Tells a slave device that you will stop reading, next bit should be an I2C stop bit. Responds 0x01.\nI2C b00001111 (0x0F) - Start bus sniffer Sniff traffic on an I2C bus.\n[/] - Start/stop bit \\ - escape character precedes a data byte value +/- - ACK/NACK Sniffed traffic is encoded according to the table above. Data bytes are escaped with the ‘' character. Send a single byte to exit, Buzzpirat responds 0x01 on exit.\nI2C b0001xxxx (0x10-0x1F) – Bulk I2C write, send 1-16 bytes (0=1byte!) Bulk I2C allows multi-byte writes. The Buzzpirat expects xxxx+1 data bytes. Up to 16 data bytes can be sent at once. Note that 0000 indicates 1 byte because there’s no reason to send 0.\nBP replies 0x01 to the bulk I2C command. After each data byte the Buzzpirat returns the ACK (0x00) or NACK (0x01) bit from the slave device.\nI2C b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS Enable (1) and disable (0) Buzzpirat peripherals and pins. Bit w enables the power supplies, bit x toggles the on-board pull-up resistors, y sets the state of the auxiliary pin, and z sets the chip select pin. Features not present in a specific hardware version are ignored. Buzzpirat responds 0x01 on success.\nNote CS pin always follows the current HiZ pin configuration. AUX is always a normal pin output (0=GND, 1=3.3volts) I2C b011000xx (0x60-0x63) - Set I2C speed, 3=~400kHz, 2=~100kHz, 1=~50kHz, 0=~5kHz 0110000x - Set I2C speed, 1=high (50kHz) 0=low (5kHz)\nThe lower bits of the speed command determine the I2C bus speed. Binary mode currently uses the software I2C library, though it may be configurable in a future update. Startup default is high-speed. Buzzpirat responds 0x01 on success.\nI2C b00001000 (0x08) - Write then read This command internally sends I2C start, writes from 0-4096 bytes, then reads 0-4096 bytes into the Buzzpirats internal buffer, ACKing each byte internally until the final byte at which point it sends an NACK stop bit.\nAll data for this command can be sent at once, and it will be buffered in the Buzzpirat. The write and read operations happen once the completed command has been passed to the Buzzpirat. Any write data is internally buffered by the Buzzpirat. At the end of the operation, any read data is returned from the buffer, be aware that the write buffer is re-used as the read buffer, as such any write data needs to be re-loaded if the command is re-executed.\nWrite then read command format:\nsend 1 byte: b00001000 (Write then read command) send 2 bytes: number of write bytes 0-4096 (first byte High8, second Low8) send 2 bytes: number of read bytes 0-4096 (first byte High8, second Low8) If the number of bytes to read or write are out of bounds, the Buzzpirat will send 0x00 now send 0-4096 bytes: bytes to write (specified by step 2. The initial byte can serve as the I2C address. Therefore, in step 2, it’s necessary to specify at least one byte for writing). read 1 byte: success/0x01, would be 0x00 If an I2C write is not ACKed by a slave device, then the operation will abort. read 0-4096 bytes: bytes to read (specified by step 3). Key points:\nThe Buzzpirat sends an I2C start bit, then all write bytes are sent at once. All read bytes are ACKed, except the last byte which is NACKed, this process is handled internally between the Buzzpirat and the I2C device. At the end of the read process, the Buzzpirat sends an I2C stop Except as described above, there is no acknowledgment that a byte is received. I2C b00001001 (0x09) Extended AUX command Provides extended use of AUX pin. Requires one command byte. Buzzpirat acknowledges 0x01.\nCommand\tFunction\nb00000000 (0x00) - AUX/CS low b00000001 (0x01) - AUX/CS high b00000010 (0x02) - AUX/CS HiZ b00000011 (0x03) - AUX read b00010000 (0x10) - use AUX b00100000 (0x20) - use CS I2C b11111110 (0xFE) - Execute Buzz Commands Buzz Commands allows for actions such as reading all voltages (similar to the ‘v’ command), manipulating the TP0 pin, etc.\nYou have access to the same commands as when you enter Buzz Mode using 0x0A. A list of the supported commands is available further below (the first one is 0x00)\nBuzzpirat returns 0x01 if it has successfully entered this mode.\nI2C Buzz Commands (0x97-0xFF) Each protocol has reserved the range from 0x97 to 0xFF for protocol-specific Buzz commands. However, none have been defined for this protocol yet.\nMAIN b00000011 (0x03) - Enter binary UART mode, responds “ART1” Enter binary UART mode by first entering bitbang mode, then send 0x03 to enter UART mode.\nMost UART mode commands are a single byte. Commands generally return 1 for success, 0 for failure.\nUART Mode, Key points Send 0x00 to the user terminal (max.) 20 times to enter the raw binary bitbang mode. Pause briefly after sending each 0x00 to check if BBIO1 is returned. Example binary mode entry functions. Enter 0x03 in bitbang mode to enter raw UART mode. Return to raw bitbang mode from raw UART mode by sending 0x00 one time. Hex values shown here, like 0x00, represent actual byte values; not typed ASCII entered into a terminal. Once you have successfully entered the mode, you can use the following commands:\nUART b00000001 (0x01) – Display mode version string, responds “ART1” Once in binary UART mode, send 0x01 to get the current mode version string. The Buzzpirat responds ‘ART1’, where 1 is the raw UART protocol version. Get the version string at any time by sending 0x01 again. This command is the same in all binary modes, the current mode can always be determined by sending 0x01.\nUART b0000001x (0x02-0x03) – Start (0)/stop(1) echo UART RX In binary UART mode the UART is always active and receiving. Incoming data is only copied to the USB side if UART RX echo is enabled. This allows you to configure and control the UART mode settings without random data colliding with response codes. UART mode starts with echo disabled. This mode has no impact on data transmissions.\nResponds 0x01. Clears buffer overrun bit.\nUART b00000111 (0x07) – Manual baud rate configuration, send 2 bytes Configures the UART using custom baud rate generator settings. This command is followed by two data bytes that represent the BRG register value. Send the high 8 bits first, then the low 8 bits.\nUse the UART manual or an online calculator to find the correct value (key values: fosc 32mHz, clock divider = 2, BRGH=1) . Buzzpirat responds 0x01 to each byte. Settings take effect immediately.\nUART b00001111 (0x0F) - UART bridge mode (reset to exit) Starts a transparent UART bridge using the current configuration. Unplug the Buzzpirat to exit.\nUART b0001xxxx (0x10-0x1F) – Bulk UART write, send 1-16 bytes (0=1byte!) Bulk UART allows multi-byte writes. The Buzzpirat expects xxxx+1 data bytes. Up to 16 data bytes can be sent at once. Note that 0000 indicates 1 byte because there’s no reason to send 0. Buzzpirat replies 0x01 to each byte.\nUART b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS Enable (1) and disable (0) Buzzpirat peripherals and pins. Bit w enables the power supplies, bit x toggles the on-board pull-up resistors, y sets the state of the auxiliary pin, and z sets the chip select pin. Features not present in a specific hardware version are ignored. Buzzpirat responds 0x01 on success.\nNote CS pin always follows the current HiZ pin configuration. AUX is always a normal pin output (0=GND, 1=3.3volts) UART b011000xx (0x60-0x63) - Set UART speed Set the UART at a preconfigured speed value: 0000=300, 0001=1200, 0010=2400,0011=4800,0100=9600,0101=19200,0110=31250 (MIDI), 0111=38400,1000=57600,1010=115200\nStart default is 300 baud. Buzzpirat responds 0x01 on success. A read command is planned but not implemented in this version.\nUART b100wxxyz (0x80-0x9F) – Configure UART settings w=pin output HiZ(0)/3.3v(1) xx=databits and parity 8/N(0), 8/E(1), 8/O(2), 9/N(3) y=stop bits 1(0)/2(1) z=RX polarity idle 1 (0), idle 0 (1) Startup default is 00000. Buzzpirat responds 0x01 on success. A read command is planned but not implemented in this version.\nNote that this command code is three bits because the databits and parity setting consists of two bits. It is not quite the same as the binary SPI mode configuration command code. UART b11111110 (0xFE) - Execute Buzz Commands Buzz Commands allows for actions such as reading all voltages (similar to the ‘v’ command), manipulating the TP0 pin, etc.\nYou have access to the same commands as when you enter Buzz Mode using 0x0A. A list of the supported commands is available further below (the first one is 0x00)\nBuzzpirat returns 0x01 if it has successfully entered this mode.\nUART Buzz Commands (0x97-0xFF) Each protocol has reserved the range from 0x97 to 0xFF for protocol-specific Buzz commands. However, none have been defined for this protocol yet.\nMAIN b00000100 (0x04) - Enter binary 1-Wire mode, responds “1W01” Enter binary 1-Wire mode by first entering bitbang mode, then send 0x04 to enter 1-Wire mode. Most 1-Wire mode commands are a single byte. Commands generally return 1 for success, 0 for failure.\n1-Wire Mode, Key points Send 0x00 to the user terminal (max.) 20 times to enter the raw binary bitbang mode. Pause briefly after sending each 0x00 to check if BBIO1 is returned. Example binary mode entry functions. Enter 0x04 in bitbang mode to enter raw 1-Wire mode. Return to raw bitbang mode from raw 1-Wire mode by sending 0x00 one time. Hex values shown here, like 0x00, represent actual byte values; not typed ASCII entered into a terminal. Once you have successfully entered the mode, you can use the following commands:\n1-Wire b00000001 (0x01) – Display mode version string, responds “1W01” Once in binary 1-Wire mode, send 0x01 to get the current mode version string. The Buzzpirat responds ‘1W01’, where 1 is the raw 1-Wire protocol version. Get the version string at any time by sending 0x01 again. This command is the same in all binary modes, the current mode can always be determined by sending 0x01.\n1-Wire b00000010 (0x02) – 1-Wire reset Send a 1-Wire reset. Responds 0x01.\n1-Wire b00000100 (0x04) – Read byte Reads a byte from the bus, returns the byte.\n1-Wire b00001000 (0x08) - ROM search macro (0xF0) 1-Wire b00001001 (0x09) - ALARM search macro (0xEC) Search macros are special 1-Wire procedures that determine device addresses. The command returns 0x01, and then each 8-byte 1-Wire address located. Data ends with 8 bytes of 0xff.\n1-Wire b0001xxxx (0x10-0x1F) – Bulk 1-Wire write, send 1-16 bytes (0=1byte!) Bulk write transfers a packet of xxxx+1 bytes to the 1-Wire bus. Up to 16 data bytes can be sent at once. Note that 0000 indicates 1 byte because there’s no reason to send 0. BP replies 0x01 to each byte.\n1-Wire b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS Enable (1) and disable (0) Buzzpirat peripherals and pins. Bit w enables the power supplies, bit x toggles the on-board pull-up resistors, y sets the state of the auxiliary pin, and z sets the chip select pin. Features not present in a specific hardware version are ignored. Buzzpirat responds 0x01 on success.\nNote CS pin always follows the current HiZ pin configuration. AUX is always a normal pin output (0=GND, 1=3.3volts) 1-Wire b11111110 (0xFE) - Execute Buzz Commands Buzz Commands allows for actions such as reading all voltages (similar to the ‘v’ command), manipulating the TP0 pin, etc.\nYou have access to the same commands as when you enter Buzz Mode using 0x0A. A list of the supported commands is available further below (the first one is 0x00)\nBuzzpirat returns 0x01 if it has successfully entered this mode.\n1-Wire Buzz Commands (0x97-0xFF) Each protocol has reserved the range from 0x97 to 0xFF for protocol-specific Buzz commands. However, none have been defined for this protocol yet.\nMAIN b00000101 (0x05) - Enter binary RAW-WIRE mode, responds “RAW1” Enter binary RAW-WIRE mode by first entering bitbang mode, then send 0x05 to enter RAW2WIRE mode.\nMost RAW-WIRE mode commands are a single byte. Commands generally return 1 for success, 0 for failure.\nRAW-WIRE Mode, Key points Send 0x00 to the user terminal (max.) 20 times to enter the raw binary bitbang mode. Pause briefly after sending each 0x00 to check if BBIO1 is returned. Enter 0x05 in bitbang mode to enter raw RAW-WIRE mode. Return to raw bitbang mode from raw RAW-WIRE mode by sending 0x00 one time. Hex values shown here, like 0x00, represent actual byte values; not typed ASCII entered into a terminal. Once you have successfully entered the mode, you can use the following commands:\nRAW-WIRE b00000001 (0x01) – Display mode version string, responds “RAW1” Once in binary RAW-WIRE mode, send 0x01 to get the current mode version string. The Buzzpirat responds ‘RAW1’, where 1 is the raw RAW-WIRE protocol version. Get the version string at any time by sending 0x01 again. This command is the same in all binary modes, the current mode can always be determined by sending 0x01.\nRAW-WIRE b0000001x (0x02-0x03) - I2C-style start (0) / stop (1) bit Send an I2C start or stop bit. Responds 0x01. Useful for I2C-like 2-wire protocols, or building a custom implementation of I2C using the raw-wire library.\nRAW-WIRE b0000010x (0x04-0x05) - CS low (0) / high (1) Toggle the Buzzpirat chip select pin, follows HiZ configuration setting. CS high is pin output at 3.3volts, or HiZ. CS low is pin output at ground. Buzzpirat responds 0x01.\nRAW-WIRE b00000110 (0x06) - Read byte Reads a byte from the bus, returns the byte. Writes 0xff to bus in 3-wire mode.\nRAW-WIRE b00000111 (0x07) - Read bit Read a single bit from the bus, returns the bit value.\nRAW-WIRE b00001000 (0x08) - Peek at input pin Returns the state of the data input pin without sending a clock tick.\nRAW-WIRE b00001001 (0x09) - Clock Tick Sends one clock tick (low-\u003ehigh-\u003elow). Responds 0x01.\nRAW-WIRE b0000101x (0x0A-0x0B) - Clock low (0) / high (1) Set clock signal low or high. Responds 0x01.\nRAW-WIRE b0000110x (0x0C-0x0D) - Data low (0) / high (1) Set data signal low or high. Responds 0x01.\nRAW-WIRE b0001xxxx (0x10-0x1F) – Bulk transfer, send 1-16 bytes (0=1byte!) Bulk write transfers a packet of xxxx+1 bytes to the bus. Up to 16 data bytes can be sent at once. Note that 0000 indicates 1 byte because there’s no reason to send 0. BP replies 0x01 to each byte in 2wire mode, returns the bus read in 3wire (SPI) mode.\nRAW-WIRE b0010xxxx (0x20-0x2F) - Bulk clock ticks, send 1-16 ticks Create bulk clock ticks on the bus. Note that 0000 indicates 1 clock tick because there’s no reason to send 0. BP replies 0x01.\nRAW-WIRE b0011xxxx (0x30-0x3F) - Bulk bits, send 1-8 bits of the next byte (0=1bit!) Bulk bits sends xxxx+1 bits of the next byte to the bus. Up to 8 data bytes can be sent at once. Note that 0000 indicates 1 byte because there’s no reason to send 0. BP replies 0x01 to each byte.\nThis is a PIC programming extension that only supports 2wire mode. All writes are most significant bit first, regardless of the mode set with the configuration command.\nRAW-WIRE b0100wxyz (0x40-0x4F) – Configure peripherals w=power, x=pullups, y=AUX, z=CS Enable (1) and disable (0) Buzzpirat peripherals and pins. Bit w enables the power supplies, bit x toggles the on-board pull-up resistors, y sets the state of the auxiliary pin, and z sets the chip select pin. Features not present in a specific hardware version are ignored. Buzzpirat responds 0x01 on success.\nNote CS pin always follows the current HiZ pin configuration. AUX is always a normal pin output (0=GND, 1=3.3volts) RAW-WIRE b011000xx (0x60-0x63) - Set bus speed, 3=~400kHz, 2=~100kHz, 1=~50kHz, 0=~5kHz The last bit of the speed command determines the bus speed. Startup default is high-speed. Buzzpirat responds 0x01.\nRAW-WIRE b1000wxyz (0x80-0x8F) – Config, w=HiZ/3.3v, x=2/3wire, y=msb/lsb, z=not used Configure the raw-wire mode settings. w= pin output type HiZ(0)/3.3v(1). x= protocol wires (0=2, 1=3), toggles between a shared input/output pin (raw2wire), and a separate input pin (raw3wire). y= bit order (0=MSB, 1=LSB). The Buzzpirat responds 0x01 on success.\nDefault raw startup condition is 000z. HiZ mode configuration applies to the data pins and the CS pin, but not the AUX pin.\nRAW-WIRE b10100100 (0xA4) - PIC write. Send command + 2 bytes of data, read 1 byte An extension for programming PIC microcontrollers. Writes 20bits to the 2wire interface.\nPayload is three bytes.\nThe first byte is XXYYYYYY, where XX are the delay in MS to hold the PGC pin high on the last command bit, this is a delay required at the end of a page write. YYYYYY is a 4 or 6 bit ICSP programming command to send to the PIC (enter 4 bit commands as 00YYYY, commands clocked in LSB first).\nThe second and third bytes are 16bit instructions to execute on the PIC.\nSee the PIC 16F/18F programming specifications for more about ICSP.\nRAW-WIRE b10100101 (0xA5) - PIC read. Send command, read 1 byte of data An extension for programming PIC microcontrollers. Writes 12bits, reads 8bits.\nPayload is one byte 00YYYYYY, where YYYYYY is a 4 or 6 bit ICSP programming command to send to the PIC. Enter 4 bit commands as 00YYYY, all commands are clocked in LSB first.\nThe Buzzpirat send the 4/6bit command, then 8 ‘0’ bits, then reads one byte. The read byte is returned.\nSee the PIC 16F/18F programming specifications for more about ICSP.\nRAW-WIRE b11111110 (0xFE) - Execute Buzz Commands Buzz Commands allows for actions such as reading all voltages (similar to the ‘v’ command), manipulating the TP0 pin, etc.\nYou have access to the same commands as when you enter Buzz Mode using 0x0A. A list of the supported commands is available further below (the first one is 0x00)\nBuzzpirat returns 0x01 if it has successfully entered this mode.\nRAW-WIRE Buzz Commands (0x97-0xFF) Each protocol has reserved the range from 0x97 to 0xFF for protocol-specific Buzz commands. However, none have been defined for this protocol yet.\nMAIN b00000110 (0x06) - Enter OpenOCD JTAG mode OpenOCD mode is documented in the source only.\nMAIN b00001010 (0x0A) - Enter Buzz mode This mode is exclusive to Buzzpirat and allows for actions such as reading all voltages (similar to the ‘v’ command), manipulating the TP0 pin, etc.\nBuzzpirat returns 0x01 if it has successfully entered this mode.\nOnce you have successfully entered to the Buzz mode via b00001010 (0x0A) (from the main bitbang) or via b11111110 (0xFE) (from a protocol mode), you can use the following Buzz mode commands:\nBuzz b01101001 (0x69) - NULL COMMAND This command doesn’t do anything; it does not return any response. It is designed for when you only want to check if the Buzz mode exists and don’t want to execute anything.\nBuzz b10010110 (0x96) - Check if firmware is BPv3 For each firmware version, I also generate a firmware that is 100% compatible with the Bus Pirate v3 hardware.\nreturns 0x01 if the firmware currently running is the version for BPv3 hardware.\nreturns 0x00 if the firmware currently running is the official version for Buzzpirat hardware.\nBuzz b00000000 (0x00) - Take voltage measurement from all sources Take a measurement from the Buzzpirat voltage sources.\nReturns a 2 byte ADC reading for 5v0 PWR, high 8bits come first. Returns a 2 byte ADC reading for 3v3 PWR, high 8bits come first. Returns a 2 byte ADC reading for 2v5 PWR, high 8bits come first. Returns a 2 byte ADC reading for 1v8 PWR, high 8bits come first. Returns a 2 byte ADC reading for VPU, high 8bits come first. Returns a 2 byte ADC reading for ADC PROBE, high 8bits come first. returns 0x01 Note At the end of this page, you will find a code to convert each 2-byte ADC value. Buzz b00000001 (0x01) - TP0 INPUT LOW Configure TP0 as INPUT LOW.\nNote TP0 is connected to VPU like MOSI, MISO.. pins. returns 0x01 if it has successfull.\nBuzz b00000010 (0x02) - TP0 OUTPUT LOW Configure TP0 as OUTPUT LOW.\nNote TP0 is connected to VPU like MOSI, MISO.. pins. returns 0x01 if it has successfull.\nBuzz b00000011 (0x03) - Read TP0 status Return 0x01 or 0x00 depending on the status of TP0 (1=HIGH, 0=LOW).\nNote TP0 is connected to VPU like MOSI, MISO.. pins. returns 0x01 if it has successfull.\nBuzz b00010000 (0x10) - Check for short circuits in the power supply units Inspect the power supply units for short circuits across the 5V, 3.3V, 2.5V, and 1.8V lines.\nReturn 0x01 if any PSU voltage is abnormally low, indicating a potential short circuit.\nReturn 0x00 if all PSU voltages are within normal parameters.\nWarning This command activates all the PSUs, checks the voltage of each one, and then turns off all the PSUs as quickly as possible Note It is recommended to use this command before executing the command: “Configure peripherals w=1” Buzz b00010010 (0x12) - Setup pulse-width modulation (requires 5 byte setup) Configure and enable pulse-width modulation output in the AUX pin.\nRequires a 5 byte configuration sequence.\nEquations to calculate the PWM frequency and period are in the PIC24F output compare manual.\nBit 0 and 1 of the first configuration byte set the prescaler value. The Next two bytes set the duty cycle register, high 8bits first. The final two bytes set the period register, high 8bits first. Responds 0x01 after a complete sequence is received.\nWarning The PWM remains active after leaving binary bitbang mode! Note Further down on this page, you will find examples of how to generate the 5 byte setup. Note This command was previously available only in the main menu; now, you can use it from any mode, including SPI, I2C, etc.. Buzz b00010011 (0x13) - Clear/disable PWM Clears the PWM, disables PWM output. Responds 0x01.\nNote This command was previously available only in the main menu; now, you can use it from any mode, including SPI, I2C, etc.. Buzz b00010100 (0x14) - Take voltage probe measurement (returns 2 bytes) Take a measurement from the Buzzpirat voltage probe. Returns a 2 byte ADC reading, high 8bits come first. To determine the actual voltage measurement: (ADC/1024)x3.3voltsx2; or simply (ADC/1024)x6.6.\nNote At the end of this page, you will find a code to convert the ADC value. Note This command was previously available only in the main menu; now, you can use it from any mode, including SPI, I2C, etc.. Buzz b00010101 (0x15) - Continuous voltage probe measurement Sends ADC data (2bytes, high 8 first) as fast as UART will allow. A new reading is not taken until the previous finishes transmitting to the PC, this prevents time distortion from the buffer. Added for the oscilloscope script.\nTo exit this mode, send any single character.\nNote This command was previously available only in the main menu; now, you can use it from any mode, including SPI, I2C, etc.. Buzz b00010110 (0x16) - Frequency measurement on AUX pin Takes frequency measurement on AUX pin. Returns 4byte frequency count, most significant byte first.\nNote This command was previously available only in the main menu; now, you can use it from any mode, including SPI, I2C, etc.. MAIN b00001111 (0x0F) - Reset Buzzpirat The Buzzpirat responds 0x01 and then performs a complete hardware reset. The hardware and firmware version is printed (same as the ‘i’ command in the terminal), and the Buzzpirat returns to the user terminal interface. Send 0x00 20 times to enter binary mode again. Note: there may be garbage data between the 0x01 reply and the version information as the PIC UART initializes.\nMAIN b00010000 (0x10) - Buzzpirat Short self-test \u0026 b00010001 (0x11) Long self-test Self-test commands\nb00010001 (0x11) Long test (requires jumpers between +5 and Vpu, +3.3 and ADC)\nThe full test is the same as self-test in the user terminal, it requires jumpers between two sets of pins in order to test some features. The short test eliminates the six checks that require jumpers.\nAfter the test is complete, the Buzzpirat responds with the number of errors. It also echoes any input plus the number of errors. The MODE LED blinks if the test was successful, or remains solid if there were errors. Exit the self-test by sending 0xff, the Buzzpirat will respond 0x01 and return to binary bitbang mode.\nMAIN b00010010 (0x12) - Setup pulse-width modulation (requires 5 byte setup) Configure and enable pulse-width modulation output in the AUX pin.\nRequires a 5 byte configuration sequence.\nEquations to calculate the PWM frequency and period are in the PIC24F output compare manual.\nBit 0 and 1 of the first configuration byte set the prescaler value. The Next two bytes set the duty cycle register, high 8bits first. The final two bytes set the period register, high 8bits first. Responds 0x01 after a complete sequence is received.\nWarning The PWM remains active after leaving binary bitbang mode! Note Further down on this page, you will find examples of how to generate the 5 byte setup. MAIN b00010011 (0x13) - Clear/disable PWM Clears the PWM, disables PWM output. Responds 0x01.\nMAIN b00010100 (0x14) - Take voltage probe measurement (returns 2 bytes) Take a measurement from the Buzzpirat voltage probe. Returns a 2 byte ADC reading, high 8bits come first. To determine the actual voltage measurement: (ADC/1024)x3.3voltsx2; or simply (ADC/1024)x6.6.\nNote At the end of this page, you will find a code to convert the ADC value. MAIN b00010101 (0x15) - Continuous voltage probe measurement Sends ADC data (2bytes, high 8 first) as fast as UART will allow. A new reading is not taken until the previous finishes transmitting to the PC, this prevents time distortion from the buffer. Added for the oscilloscope script.\nTo exit this mode, send any single character.\nMAIN b00010110 (0x16) - Frequency measurement on AUX pin Takes frequency measurement on AUX pin. Returns 4byte frequency count, most significant byte first.\nMAIN b010xxxxx (0x40-0x5F) - Configure pins as input(1) or output(0): AUX|MOSI|CLK|MISO|CS Configure pins as an input (1) or output(0). The pins are mapped to the lower five bits in this order:\nAUX|MOSI|CLK|MISO|CS. The Buzzpirat responds to each direction update with a byte showing the current state of the pins, regardless of direction. This is useful for open collector I/O modes.\nMAIN b1xxxxxxx (0x80-0xFF) - Set on (1) or off (0): POWER|PULLUP|AUX|MOSI|CLK|MISO|CS The lower 7bits of the command byte control the Buzzpirat pins and peripherals. Bitbang works like a player piano or bitmap. The Buzzpirat pins map to the bits in the command byte as follows:\n1|POWER|PULLUP|AUX|MOSI|CLK|MISO|CS The Buzzpirat responds to each update with a byte in the same format that shows the current state of the pins.\nADC Calculation Python 3 #!/usr/bin/env python3 adc_high = 0x03 adc_low = 0x08 adc_buzz = (adc_high \u003c\u003c 8) + adc_low print(f\"Combined ADC value (hex): {hex(adc_buzz)}\") result = (adc_buzz / 1024) * 6.6 print(f\"Result for ADC value {adc_buzz} (hex {hex(adc_buzz)}): {result}\") Output:\nCombined ADC value (hex): 0x308 Result for ADC value 776 (hex 0x308): 5.0015624999999995 C #include \u003cstdio.h\u003e int main() { unsigned char adc_high = 0x03; unsigned char adc_low = 0x08; unsigned int adc_buzz = (adc_high \u003c\u003c 8) + adc_low; printf(\"Combined ADC value (hex): 0x%x\\n\", adc_buzz); double result = (((double)adc_buzz) / 1024.0) * 6.6; printf(\"Result for ADC value %u (hex 0x%x): %f\\n\", adc_buzz, adc_buzz, result); return 0; } Output:\nCombined ADC value (hex): 0x308 Result for ADC value 776 (hex 0x308): 5.001562 PWM Computation Python 3 Here is a Python Script for computing the PWM for Buzzpirat.\nFor example, setup PWM with Period of 1msec, 50% duty cycle. Using 1:1 Prescaler.\nModify only the 3 lines:\nPrescaler=1 # 1:1 PwmPeriod=1e-3 # 0.1msec DutyCycleInPercent=.5 # 50% It will output:\n====================== PwmPeriod: 0.00100000000000000002 sec. Tcy: 0.00000006250000000000 sec. Prescaler: 1 PR2: 0x3e7f = 15999 OCR: 0x1f3f = 7999 5 Byte Setup: 1st Byte: 0x00 2nd Byte: 0x1f 3rd Byte: 0x3f 4th Byte: 0x3e 5th Byte: 0x7f Use the 5byte setup to set the PWM.\n#!/usr/bin/env python3 ''' Python Script 00.08.00 - by 7 mod by Dreg ''' # 32MHz Crystal Oscillator Fosc = 32e6 # DONT MODIFY THIS Prescaler = 1 # [1, 8, 64, 256] PwmPeriod = 1e-3 # 0.1 msec DutyCycleInPercent = 0.5 # 50% ################################################### #### ---------------------------------------- ##### #### -- DON'T MODIFY ANYTHING BELOW THIS LINE ##### #### ---------------------------------------- ##### ################################################### ''' Configure and enable pulse-width modulation output in the AUX pin. Requires a 5 byte configuration sequence. Responds 0x01 after a complete sequence is received. The PWM remains active after leaving binary bitbang mode! Equations to calculate the PWM frequency and period are in the PIC24F output compare manual. Bit 0 and 1 of the first configuration byte set the prescaler value. The Next two bytes set the duty cycle register, high 8 bits first. The final two bytes set the period register, high 8 bits first. ''' PrescalerList = {1: 0, 8: 1, 64: 2, 256: 3} Tcy = 2.0 / Fosc PRy = PwmPeriod / (Tcy * Prescaler) PRy = PRy - 1 OCR = PRy * DutyCycleInPercent print(\"======================\") print(f\"PwmPeriod: {PwmPeriod:.20f} sec.\") print(f\"Tcy: {Tcy:.20f} sec.\") print(f\"Prescaler: {int(Prescaler)}\") print(f\"PR2: 0x{int(PRy):x} = {int(PRy)}\") print(f\"OCR: 0x{int(OCR):x} = {int(OCR)}\") ##### print(\"5 Byte Setup:\") print(f\"1st Byte: 0x{int(PrescalerList[Prescaler]):02x}\") print(f\"2nd Byte: 0x{(int(OCR) \u003e\u003e 8) \u0026 0xFF:02x}\") print(f\"3rd Byte: 0x{int(OCR) \u0026 0xFF:02x}\") print(f\"4th Byte: 0x{(int(PRy) \u003e\u003e 8) \u0026 0xFF:02x}\") print(f\"5th Byte: 0x{int(PRy) \u0026 0xFF:02x}\") C #include \u003cstdio.h\u003e int main() { // 32MHz Crystal Oscillator double Fosc = 32e6; // DON'T MODIFY THIS unsigned int Prescaler = 1; //unsigned int Prescaler = 8; //unsigned int Prescaler = 64; //unsigned int Prescaler = 256; double PwmPeriod = 1e-3; // 0.1 msec double DutyCycleInPercent = 0.5; // 50% // DON'T MODIFY ANYTHING BELOW THIS LINE // Configure and enable pulse-width modulation output in the AUX pin unsigned int listv; switch (Prescaler) { case 1: listv = 0; break; case 8: listv = 1; break; case 64: listv = 2; break; case 256: listv = 3; break; default: listv = 0; break; } double Tcy = 2.0 / Fosc; double PRy = PwmPeriod / (Tcy * Prescaler); PRy = PRy - 1; double OCR = PRy * DutyCycleInPercent; printf(\"======================\\n\"); printf(\"PwmPeriod: %.20f sec.\\n\", PwmPeriod); printf(\"Tcy: %.20f sec.\\n\", Tcy); printf(\"Prescaler: %u\\n\", Prescaler); printf(\"PR2: 0x%x = %u\\n\", (unsigned int)PRy, (unsigned int)PRy); printf(\"OCR: 0x%x = %u\\n\", (unsigned int)OCR, (unsigned int)OCR); printf(\"5 Byte Setup:\\n\"); printf(\"1st Byte: 0x%02x\\n\", listv); printf(\"2nd Byte: 0x%02x\\n\", ((unsigned int)OCR \u003e\u003e 8) \u0026 0xFF); printf(\"3rd Byte: 0x%02x\\n\", (unsigned int)OCR \u0026 0xFF); printf(\"4th Byte: 0x%02x\\n\", ((unsigned int)PRy \u003e\u003e 8) \u0026 0xFF); printf(\"5th Byte: 0x%02x\\n\", (unsigned int)PRy \u0026 0xFF); return 0; } Output:\n====================== PwmPeriod: 0.00100000000000000002 sec. Tcy: 0.00000006250000000000 sec. Prescaler: 1 PR2: 0x3e7f = 15999 OCR: 0x1f3f = 7999 5 Byte Setup: 1st Byte: 0x00 2nd Byte: 0x1f 3rd Byte: 0x3f 4th Byte: 0x3e 5th Byte: 0x7f ","categories":"","description":"Binary I/O mod from dangerousprototypes","excerpt":"Binary I/O mod from dangerousprototypes","ref":"/docs/binaryio/","tags":"","title":"Binary I/O"},{"body":" Warning Do not install this firmware on the Bus Pirate v3. Please refer to the lower section of this page for compatible firmware options Download the last firmware from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/stablefirm Warning Do not install the firmware labeled with “pickit” in its name Download the last buzzloader app (There are versions available for Windows, Linux and Mac) from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/buzzloader\nput a jumper/dupont_wire connecting the PGD pin to the PGC pin\nconnect the buzzpirat to your computer via a usb cable\ncheck for the new COM port assignment in the device manager (e.g., COM29)\nMake sure to close Tera Term or any other software that might be using the COM port to free it up and execute:\nbuzzloader.exe --dev=COM29 --hex=BZ-firmware-v7.1.6969.hex Just ignore a800…ERROR[50] error message, it’s a known issue and the firmware is updated correctly.\nWriting page 41 row 331, a580...OK Writing page 41 row 332, a600...OK Writing page 41 row 333, a680...OK Writing page 41 row 334, a700...OK Writing page 41 row 335, a780...OK Erasing page 42, a800...ERROR [50] Error updating firmware :( Remove the jumper/Dupont cable, then reconnect the device to the USB port, and you’re all set! You should now have the latest firmware installed.\nRun the ‘i’ command and perform a self-test with the ‘~’ command to ensure everything has gone smoothly.\nBuzzpirat firmware for BPv3 hardware For each firmware version, I also generate a firmware that is 100% compatible with the Bus Pirate v3 hardware.\nSo, users with the Bus Pirate v3 hardware can benefit from Buzzpirat features:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/stablefirm/bpv3comp To ensure compatibility with Buzzpirat firmware, you need to install bootloader 4.5\nMore information on how to update it can be found here:\nhttp://dangerousprototypes.com/forum/index.php?topic=8498.0 Warning BOOTLOADER UPDATE IS RISKY, YOU COULD BRICK YOUR BUS PIRATE, AND I AM NOT RESPONSIBLE FOR ANY DAMAGES. LEARN HOW TO UNBRICK Last community BPv3 firmware \u0026 bootloader Any firmware and bootloader from the original Bus Pirate v3 will work well with Buzzpirat. Here are some that I have tested.\n4.5 Bootloader upgrade from v4x:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/oldfirm/BPv3-bootloader-upgrade-v4xtov4.5_Aug-2023_USBEprom.hex Last community firmware:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/oldfirm/BPv3-firmware-v7.1-JTAG_SAFE_1_Aug-2023_USBEprom.hex Note This community firmware have a bug in the binary SPI mode and cause problems with flashrom Legacy BPv3 firmware \u0026 bootloader 4.4 Bootloader:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/oldfirm/BPv3-Bootloader-v4.4.hex 6.3-r2151 Firmware:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/oldfirm/BPv3-firmware-v6.3-r2151.hex ","categories":"","description":"How to update your Buzzpirat","excerpt":"How to update your Buzzpirat","ref":"/docs/firmware-update/","tags":"","title":"Firmware Update"},{"body":"Once you have understood the ‘Getting Started’ section, here you can delve deeper into the use of Buzzpirat.\nThe Buzzpirat is controlled by text commands entered through the serial terminal. If the terminal is blank, press enter to show the command prompt. Press ‘?’, followed by enter, to show the help menu.\nMenus configure various Buzzpirat options like pull-up resistors, terminal speed, data display format (DEC, HEX, BIN), etc. Type the menu command, followed by enter, to display the options. Syntax is used to interact with a device connected over a bus. Commands are mostly single characters, such as ‘r’ to read a byte. Enter up to 4000 characters of syntax, press enter to execute the sequence.\nMost menus have a default option shown in () before the prompt:\nOutput type: 1. High-Z outputs (H=input, L=GND) 2. Normal outputs (H=Vcc, L=GND) (1) \u003e \u003c\u003c\u003c option 1 is the default Press enter to select the default option. Terminal Configuration commands ‘?’ Help menu with latest menu and syntax options ‘i’ Hardware, firmware, microcontroller version information ’m’ Set bus mode (1-Wire, SPI, I2C, JTAG, UART, etc) ‘h’ Command history ‘c’/‘C’ Toggle AUX control between AUX and CS/TMS pins ’l’/‘L’ Set MSB/LSB first in applicable modes ‘o’ Data display format (DEC, HEX, BIN, or raw) ‘b’ Set PC side serial port speed ‘~’ Perform a self-test ‘#’ Reset ‘$’ Jump to bootloader Utilities commands ‘w’/‘W’ Power supplies (off/ON) ‘v’ Power supply voltage report ‘p’/‘P’ Pull-up resistors ‘f’ Measure frequency on the AUX pin ‘g’ Frequency generator/PWM on the AUX pin ‘S’ Servo ‘=’ Convert to HEX/DEC/BIN number format ‘|’ Reverse bits in byte ’s’ BASIC script engine ’d’/‘D’ Measure from voltage probe (once/CONTINUOUS) ‘a’/‘A’/’@’ Control axillary pin (low/HIGH/read) Macros, user macros (0) List mode macros (#) Run macro \u003cx= \u003e Assign user macro \u003c0\u003e List user macros \u003c#\u003e Run user macro Bitwise bus commands ‘^’ Send one clock tick ‘/’ or ‘\\’ Toggle clock level high (/) and low (\\) ‘-’ or ‘_’ Toggle data state high (-) and low (’_’) ‘!’ Read one bit with clock ‘.’ Read data pin state (no clock) Bus interaction commands ‘{’ or ‘[’ Bus start condition ‘]’ or ‘}’ Bus stop condition ‘r’ Read byte 0b01 Write this binary value 0x01 Write this HEX value 0-255 Write this decimal value “abc” Write this ASCII string ’ ’ (space), Value delimiter ‘\u0026’/’%’ Delay 1uS/MS ‘:’ Repeat (e.g. r:10) ‘;’ Partial (\u003c16 bit) read/write (e.g. 0x55;3) 1-Wire Syntax Macro UART Configuration options Syntax ‘r’ read a byte Parity and framing errors Buffer overrun errors Custom baud rate Macros MIDI Connections I2C Configuration options Syntax Macro ACK/NACK management Connections SPI Configuration options Syntax Macro SPI Bus sniffer Clock edge/clock polarity/sample phase macros Connections Raw 2-wire Configuration options Syntax Macro Connections Raw 3-wire Configuration options Syntax Connections HD44780 LCDs Syntax Macro PC keyboard Syntax Macro DIO BASIC script reference NEW LIST RUN Variables LET IF {ifstat} THEN {truestat} ELSE {falsestat} GOTO {line} GOSUB {line} and RETURN REM {text} PRINT {text} INPUT {question},{var} FOR {var}={minvalue} TO {maxvalue} {stats} NEXT {var} READ {var} \u0026 DATA {val1}, {val2}, .. {val1}, {val2}, START STOP STARTR STOPR SEND {val/var} RECEIVE CLK {val} DAT {val} BITREAD ADC AUX {val} AUXPIN {val} PSU {val} PULLUP {val} DELAY {var} FREQ {var} \u0026 DUTY {var} Terminal Talk to the Buzzpirat from a serial terminal set to 115200bps, 8/N/1\nThe Buzzpirat understands some VT-100 (ANSI C0) terminal emulation.\nKeyboard Key Ctrl-Key Action [left arrow] ^B Moves the cursor left one character [right arrow] ^F Moves the cursor right one character [up arrow] ^P Copies the previous command in the command history buffer to the command line [down arrow] ^N Copies the next command in the command history buffer to the command line ^A Moves the cursor to the beginning of the line ^E Moves the cursor to the end of the line [backspace] ^H Erases the character to the left of the cursor and moves the cursor left one character [delete] ^D Erases the character under (or to the right of) the cursor and moves the cursor left one character Configuration commands ‘?’ Help menu with latest menu and syntax options Print a help screen with all available menu and syntax options in the current firmware and hardware.\nHiZ\u003e? General Protocol interaction --------------------------------------------------------------------------- ? This help (0) List current macros =X/|X Converts X/reverse X (x) Macro x ~ Selftest [ Start # Reset the BP ] Stop $ Jump to bootloader { Start with read \u0026/% Delay 1 us/ms } Stop a/A/@ AUXPIN (low/HI/READ) \"abc\" Send string b Set baudrate 123 c/C AUX assignment (aux/CS) 0x123 d/D Measure ADC (once/CONT.) 0b110 Send value f Measure frequency r Read g/S Generate PWM/Servo / CLK hi h Commandhistory \\ CLK lo i Versioninfo/statusinfo ^ CLK tick l/L Bitorder (msb/LSB) - DAT hi m Change mode _ DAT lo o Set output type . DAT read p/P Pullup resistors (off/ON) ! Bit read s Script engine : Repeat e.g. r:10 v Show volts/states . Bits to read/write e.g. 0x55.2 w/W PSU (off/ON) \u003cx\u003e/\u003cx= \u003e/\u003c0\u003e Usermacro x/assign x/list all e/E TP0 (input-low+READ/output-low) (TP0 is connected to VPU) HiZ\u003e ‘i’ Hardware, firmware, microcontroller version information The information menu displays the hardware, firmware, and microcontroller version.\nHiZ\u003e i Buzzpirat v3.5 \u003c\u003c\u003chardware version Community Firmware v7.1 - buzzpirat.com by Dreg LASTDEV [HiZ 1-WIRE UART I2C SPI 2WIRE 3WIRE KEYB LCD PIC DIO] Bootloader v4.5 \u003c\u003c\u003cfirmware and bootloader version, project webpage DEVID:0x0447 REVID:0x3046 (24FJ64GA00 2 B8) \u003c\u003c\u003cPIC device ID and revision http://dangerousprototypes.com \u003c\u003c\u003cdangerousprototypes webpage HiZ\u003e\nIf a bus mode is configured additional information about the configuration options is printed.\n*----------* POWER SUPPLIES OFF Voltage monitors: 5V: 0.0 | 3.3V: 0.0 | VPULLUP: 0.0 | a/A/@ controls AUX pin Normal outputs (H=V+, L=GND) Pull-up resistors ON MSB set: MOST sig bit first * ----------* RAW2WIRE\u003e ’m’ Set bus mode (1-Wire, SPI, I2C, JTAG, UART, etc) Select a bus mode. The command resets the Buzzpirat and immediately disables all pins, pull-up resistors, and power supplies.\nThe default mode is HiZ, a safe mode with all pins set to high-impedance and all peripherals disabled.\nHiZ\u003em 1. HiZ 2. 1-WIRE 3. UART 4. I2C 5. SPI 6. 2WIRE 7. 3WIRE 8. KEYB 9. LCD 10. PIC 11. DIO x. exit(without change) (1)\u003e ‘h’ Command history The previous 10 commands can be replayed from the command history menu.\nSPI\u003e h 1. h 2. [10 r:3] 3. m 4. i x. exit (0)\u003e 2 \u003c\u003c\u003creplay #2 CS ENABLED WRITE: 0x0A READ: 0x00 0x00 0x00 CS DISABLED SPI\u003e ‘c’/‘C’ Toggle AUX control between AUX and CS/TMS pins Sometimes it’s useful to control the CS pin from the user terminal. The c/C configures the a/A/@ commands to control the AUX or CS pins.\n3WIRE\u003e c a/A/@ controls AUX pin 3WIRE\u003e C a/A/@ controls CS/TMS pin 3WIRE\u003e ’l’/‘L’ Set MSB/LSB first in applicable modes The l/L command determines the bit order for reading and writing bytes in some bus modes. The bitorder command is available in all modes\n3WIRE\u003e l MSB set: MOST sig bit first 3WIRE\u003e L MSB set: LEAST sig bit first 3WIRE\u003e ‘o’ Data display format (DEC, HEX, BIN, or raw) The Buzzpirat can display values as hexadecimal, decimal, binary, and a raw ASCII byte. Change the setting in the data display format menu (o). The default display format is HEX.\nThe RAW display mode sends values to the terminal as raw byte values without any text conversion. This is useful for ASCII serial interfaces. It can also be used to speed up the display of bus sniffers and other high-speed functions where converting raw bytes to text takes too much time. Adjust the display format in your serial terminal to see the raw values as HEX/DEC/BIN.\nHiZ\u003e o 1. HEX 2. DEC 3. BIN 4. RAW (1)\u003e Display format set HiZ\u003e ‘b’ Set PC side serial port speed Adjust the speed of the serial port facing the computer (and USB-\u003eserial converter chip).\nAfter choosing a speed you must adjust the serial terminal and press space to continue. The Buzzpirat will pause until the space key is pressed to verify that the terminal speed is correct.\n(9)\u003e 10 Enter raw value for BRG (34)\u003e 34 Adjust your terminal Space to continue HiZ\u003e There is an option to set a custom baud rate with a raw BRG value. The value can be calculated according to the datasheet or with a utility (key constants: PIC24, 32MHz/16MIPS, BRGH=1): https://github.com/therealdreg/buzzpirat/tree/main/bin/picbaud/\n230400 baud is ‘16’ (2.2% error) 460800 baud is ‘8’ (3.3% error) 921600 baud is ‘3’ (8.51% error) One thing to note is that on some early PIC revisions (A3) the UART is weird and the exact values won’t work. On these chips try a value +/-1.\nHiZ\u003e b Set serial port speed: (bps) 1. 300 2. 1200 3. 2400 4. 4800 5. 9600 6. 19200 7. 38400 8. 57600 9. 115200 10. BRG raw value (9)\u003e Adjust your terminal Space to continue HiZ\u003e ‘~’ Perform a self-test Perform a hardware self-test. Requires jumpers between +5 and Vpu, +3.3 and ADC.\nHiZ\u003e ~ Disconnect any devices Connect (Vpu to +5V) and (ADC to +3.3V) Space to continue ‘#’ Reset Reset the Buzzpirat.\nHiZ\u003e# RESET Buzzpirat v3.5 Community Firmware v7.1 - buzzpirat.com by Dreg LASTDEV [HiZ 1-WIRE UART I2C SPI 2WIRE 3WIRE KEYB LCD PIC DIO] Bootloader v4.5 DEVID:0x0447 REVID:0x3046 (24FJ64GA00 2 B8) http://dangerousprototypes.com HiZ\u003e ‘$’ Jump to bootloader Bootloader v4.5 will respond with a version string if a key is pressed while it’s active.\nHiZ\u003e $ Are you sure? y BOOTLOADER Enter the bootloader for a firmware update without connecting the PGC and PGD pins. Remember to disconnect your terminal program before the upgrade. BL4+BL4+ Utilities commands ‘w’/‘W’ Power supplies (off/ON) Toggle the switchable 1.8volt, 2.5volt, 3.3volt and 5.0volt power supplies with the w/W command. Capital ‘W’ enables the supplies, lowercase ‘w’ disables them. The power supplies on the Buzzpirat can supply up to 300mA\n1-WIRE\u003e w POWER SUPPLIES OFF 1-WIRE\u003e W POWER SUPPLIES ON 1-WIRE\u003e ‘v’ Power supply voltage report The voltage report shows the current state of all the Buzzpirat pins and peripherals.\nThe first line is the pin number, according to the silk screen on the v3 PCB, and the wire color. T\nThe second line is the pin function in the current bus mode. The power supplies (1.8v, 2.5v, 3.3v, 5.0v), ADC, Vpu, and AUX pins are available in all modes. The other four pins will differ depending on the mode. In 1-Wire mode only one pin is used, one wire data (OWD).\nThe third line shows the current direction of each pin. I is an input pin, O is an output pin, P is a power supply.\nThe fourth line shows the current state of each pin. A voltage measurement is displayed for analog pins. The current pin reading, H high and L low, is printed for each digital pins.\nI2C\u003ev Pinstates: 1.(BR) 2.(RD) 3.(OR) 4.(YW) 5.(GN) 6.(BL) 7.(PU) 8.(GR) 9.(WT) 0.(Blk) GND 3.3V 5.0V ADC VPU AUX SCL SDA - - P P P I I I I I I I GND 3.31V 4.87V 0.00V 2.44V L H H H H 1.(BR) 2.(RD) 3.(OR) 2.5V 1.8V TP0 P P I 2.50V 1.79V H I2C\u003e ‘p’/‘P’ Pull-up resistors p and P toggle the pull-up resistors off and on.\nThe on-board pull-up resistors must be powered through the Vpullup pin of the IO header. A warning is displayed if there’s no voltage on the Vpullup pin. Check the voltage report (‘v’) and verify that Vpu is attached to a power supply. See the practical guide to Buzzpirat pull-up resistors for a simple introduction.\nPull-up resistors are generally used with open collector/open drain bus types. A warning is displayed when the pull-ups are enabled if the Buzzpirat is configured for normal pin output.\nI2C\u003eP Pull-up resistors ON I2C\u003e ‘f’ Measure frequency on the AUX pin Measures frequency from 0Hz to 40MHz on the AUX pin, the method is an actual 1 second tick count. If the frequency is lower than a few MHz, the Buzzpirat does an ‘autorange’ and measures the frequency again for an additional second.\n2WIRE\u003e f Frequency on AUX pin: autorange 50,283 Hz 2WIRE\u003e ‘g’ Frequency generator/PWM on the AUX pin Enable the frequency generator with g, then set frequency and duty cycle. Frequencies from 1kHz to 4MHz are possible. Use g again to disable the PWM.\nNote that the resolution at 4MHz is only 1 bit. Anything other than 50% duty cycle will be 100% off or 100% on.\n2WIRE\u003e g 1KHz-4,000KHz PWM/frequency generator Frequency in KHz (50)\u003e 2000 Duty cycle in % (50)\u003e PWM active 2WIRE\u003e g PWM disabled 2WIRE\u003e ‘S’ Servo S positions the servo arm to the desired angle, 0-180 degrees. The servo value can be updated as needed, press enter or x to exit. Use ‘S’ or ‘g’ again to disable the servo.\n1-WIRE\u003eS Position in degrees (90)\u003e20 Servo active (x)\u003e100 Servo active (x)\u003e30 Servo active (x)\u003e 1-WIRE\u003eS PWM disabled 1-WIRE\u003eS 90 %:5000 S 180 Servo active DELAY 5000ms Servo active 1-WIRE\u003e Warning Some servos draw more current than the Buzzpirat can supply!! Use an external power supply instead. ‘=’ Convert to HEX/DEC/BIN number format Base conversion command, available in all modes. Press ‘=’ and enter any byte value to see the HEX/DEC/BIN equivalent. Firmware v2.1+\n2WIRE\u003e =0b110 0x06 = 6 = 0b00000110 2WIRE\u003e =0xa 0x0A = 10 = 0b00001010 2WIRE\u003e =12 0x0C = 12 = 0b00001100 2WIRE\u003e ‘|’ Reverse bits in byte Reverse bit order in byte X. Displays the HEX/DEC/BIN value of the reversed byte.\nI2C\u003e |0b10101010 0x55 = 85 = 0b01010101 I2C\u003e |0b10000000 0x01 = 1 = 0b00000001 I2C\u003e |1 0x80 = 128 = 0b10000000 I2C\u003e ’s’ BASIC script engine Simple BASIC scripts can automate repetitive and tedious tasks.\n2WIRE\u003e s 2WIRE(BASIC)\u003e list 65535 bytes. Ready. 2WIRE(BASIC)\u003e ’d’/‘D’ Measure from voltage probe (once/CONTINUOUS) A lowercase d takes a measurement from the voltage measurement probe (ADC pin on the IO header).\nA capital D takes continuous measurements from the voltage probe, press any key to exit.\nThe Buzzpirat voltage probe can measure up to 6.0volts (max 6.6volts, but with some margin for error).\nHiZ\u003e d VOLTAGE PROBE: 3.31V HiZ\u003e D VOLTMETER MODE Any key to exit VOLTAGE PROBE: 3.30V ‘a’/‘A’/’@’ Control axillary pin (low/HIGH/read) The axillary pin is a general purpose digital pin that can be controlled from the Buzzpirat terminal. Capital A makes it a 3.3volt output (25mA max). Lowercase a makes it sink to ground (25mA max). @ makes in an input and reads the current state (5volt maximum input).\na/A/@ can also be used to control the CS pin using the ‘c’/‘C’ commands.\nUART\u003e A AUX HIGH UART\u003e a AUX LOW UART\u003e @ AUX INPUT/HI-Z, READ: 0 UART\u003e Macros, user macros Macros perform complex actions, like scanning for I2C addresses, interrogating a smart card, or probing a JTAG chain. Macros are numbers entered inside (). Macro (0) always displays a list of macros available in the current bus mode.\n(0) List mode macros I2C\u003e (0) 0.Macro menu 1.7bit address search 2.I2C sniffer I2C\u003e Macro (0) always displays a list of macros available in the current bus mode.\n(#) Run macro I2C\u003e(1)\u003c\u003c\u003cI2C search macro Searching 7bit I2C address space. Found devices at: 0xA0(0x50 W) 0xA1(0x50 R) I2C\u003e Execute a macro by typing the macro number between ().\n\u003cx= \u003e Assign user macro I2C\u003e \u003c1=[0xa1 r:8]\u003e I2C\u003e 5 user macros can be stored to automate common commands. Each position can store 32 chars (including space).\n\u003c0\u003e List user macros I2C\u003e \u003c0\u003e 1. \u003c[0xa1 r:8]\u003e 2. \u003c\u003e 3. \u003c\u003e 4. \u003c\u003e 5. \u003c\u003e I2C\u003e User macro \u003c0\u003e lists the currently stored use macros.\n\u003c#\u003e Run user macro I2C\u003e \u003c1\u003e I2C\u003e [0xa1 r:8] Enter the macro number to recall the command. Press enter to execute.\nBitwise bus commands Bitwise commands are only available in certain bus modes.\n‘^’ Send one clock tick 2WIRE\u003e ^ CLOCK TICK 2WIRE\u003e Send one clock tick. ^:1…255 for multiple clock ticks.\n‘/’ or ‘\\’ Toggle clock level high (/) and low (\\) 2WIRE\u003e /\\ CLOCK, 1 CLOCK, 0 2WIRE\u003e Set the clock signal high or low. Includes clock delay.\n‘-’ or ‘_’ Toggle data state high (-) and low (’_’) 2WIRE\u003e -_ DATA OUTPUT, 1 DATA OUTPUT, 0 2WIRE\u003e Set the data signal high or low. Includes data setup delay\n‘!’ Read one bit with clock 2WIRE\u003e ! READ BIT: 0 *pin is now HiZ 2WIRE\u003e Send one clock tick and read one bit from the bus.\nOn a bus with a bi-directional data line (raw2wire, 1-Wire), the data pin is left as a high-impedance input after this command.\n‘.’ Read data pin state (no clock) 2WIRE\u003e . 0 *pin is now HiZ 2WIRE\u003e Make the data pin an input and read, but do not send a clock. This can be used as /.\\ to achieve the same thing as the ! command.\nOn a bus with a bi-directional data line (raw2wire, 1-wire), the data pin is left as a high-impedance input after this command.\nBus interaction commands These commands actually manipulate the bus and interacts with chips. These commands have the same general function in each bus mode, such as ‘r’ to read a byte of data. See the individual bus mode guides for each protocol.\n‘{’ or ‘[’ Bus start condition I2C\u003e [ I2C START BIT I2C\u003e This command generally starts bus activity. In various modes it starts (I2C), selects (SPI), resets (1-wire), or opens (UART).\n‘]’ or ‘}’ Bus stop condition SPI\u003e ] CS DISABLED SPI\u003e This command generally stops bus activity. In various modes it stops (I2C), deselects (SPI), or closes (UART).\n‘r’ Read byte I2C\u003e r READ: 0x00 I2C\u003e r:3 READ: ACK 0x00 ACK 0x00 ACK 0x00 I2C\u003e r reads a byte from the bus. Use with the repeat command (r:1…255) for bulk reads.\n0b01 Write this binary value I2C\u003e 0b1001 WRITE: 0x09 ACK I2C\u003e 0b1001:2 WRITE: 0x09 ACK 0x09 ACK I2C\u003e Enter a binary value to write it to the bus.\nBinary values are commonly used in electronics because the 1’s and 0’s correspond to register ‘switches’ that control various aspects of a device. Enter a binary number as 0b and then the bits. Padding 0’s are not required, 0b00000001=0b1. Can be used with the repeat command.\n0x01 Write this HEX value SPI\u003e 0x15 WRITE: 0x15 SPI\u003e 0xfa:5 WRITE: 0xFA 0xFA 0xFA 0xFA 0xFA SPI\u003e Enter a HEX value to write it to the bus.\nHexadecimal values are base 16 numbers that use a-f for the numbers 10-15, this format is very common in computers and electronics. Enter HEX values as shown above, precede the value with 0x or 0h. Single digit numbers don’t need 0 padding, 0x01 and 0x1 are interpreted the same. A-F can be lower-case or capital letters.\n0-255 Write this decimal value SPI\u003e 18 WRITE: 0x12 SPI\u003e 13:5 WRITE: 0x0D 0x0D 0x0D 0x0D 0x0D SPI\u003e Any number not preceded by 0x, 0h, or 0b is interpreted as a decimal value and sent to the bus.\nDecimal values are common base 10 numbers. Just enter the value, no special designator is required.\n“abc” Write this ASCII string SPI\u003e \"abcd\" WRITE: \"abcd\" SPI\u003e The ASCII values enclosed in \"\" are sent to the bus.\n’ ’ (space), Value delimiter SPI\u003e [1 2,3rr] CS ENABLED WRITE: 0x01 WRITE: 0x02 WRITE: 0x03 READ: 0x0A READ: 0x0A CS DISABLED SPI\u003e Use a coma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values.\n‘\u0026’/’%’ Delay 1uS/MS SPI\u003e \u0026 DELAY 1us SPI\u003e \u0026:10 DELAY 10us SPI\u003e % DELAY 1ms SPI\u003e %:10 DELAY 10ms SPI\u003e \u0026 delays 1us, % delays 1ms. Use the repeat command for multiple delays.\n‘:’ Repeat (e.g. r:10) SPI\u003e \u0026:10 DELAY 10us SPI\u003e r:0b10 READ: 0x00 0x00 SPI\u003e 5:0x3 WRITE: 0x05 0x05 0x05 SPI\u003e Many Buzzpirat commands can be repeated by adding ‘: ’ to a command, followed by the number of times to repeat the command. To read five byte, enter r:5, etc. The repeat values can be HEX/DEC/BIN.\n‘;’ Partial (\u003c16 bit) read/write (e.g. 0x55;3) 2WIRE\u003e 0xaa;4 WRITE: 0x0A;4 Will write 0x0a (4 bits) to the bus.\n2WIRE\u003e 0xFFFF;12 WRITE: 0x0FFF;12 Will write 0x0FFF (12 bits) to the bus.\n2WIRE\u003e 0x55:4;2 WRITE: 0x01;2 0x01;2 0x1;2 0x01;2 Can be combined with the repeat command.\nNOTE: works currently only with the raw2wire and raw3wire busses.\n1-Wire Bus: 1-Wire (Dallas/Maxim 1-Wire protocol). Connections: one pin (OWD) and ground. Output types: open drain/open collector, pull-up resistor required. Pull-up resistors: always required (2K – 10K, 2K or less for parasitic power parts). Maximum voltage: 5.5volts (5volt safe). 1-Wire uses a single data signal wire. Most devices also require a power and ground connection. Some parts draw power parasitically through the 1-Wire bus and don’t require a separate power source.\nSyntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). { or [ 1-Wire bus reset. ] or } – r Read one byte. (r:1…255 for bulk reads) 0b Write this binary value. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value. Format is 0×01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a coma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Bitwise - ^ One clock tick, use data state from previous – or _ operation. (^:1…255 for multiple clock ticks) / or \\ – - or _ Set the 1-Wire data state to 1 (-) or 0 (_). This will be used on the next ^ command, no actual bus change. (updated in v5.2, this previously set the state and sent a bit) ! Read one bit with clock. . Read current data state setting from last - or _ command, no actual bus change. Macro Command Description 0 Macro menu 1-50 Reserved for device address shortcuts. 51 READ ROM (0×33) *for single device bus 85 MATCH ROM (0×55) *followed by 64bit address 204 SKIP ROM (0xCC) *followed by command 236 ALARM SEARCH (0xEC) 240 SEARCH ROM (0xF0) Notes:\n1-Wire specifies a 2K or smaller resistor when working with parasitically powered devices. Since v3a the on-board pull-up resistor on MOSI are 2K. Use an external 2K pull-up resistor if you have a v2go. Parasitically powered parts may appear to work with resistors larger than 2K ohms, but will fail certain operations (like EEPROM writes).\nThe 1-wire reset command can detect two bus errors. If no 1-wire chips respond to the reset command by pulling the bus low, it will report *No device detected (0x02). If the bus stays low for too long after the reset, because the pull-up resistor isn’t working or there’s a short circuit, it will report *Short or no pull-up (0x01).\nOne wire is a time sensitive protocol. There’s no actual data wire to set high or low with the - and _ commands, so I just store the desired value and send it with the next clock tick (^).\nThe _ and - commands just set the data state that will be used on the next clock tick command (^). Example: previously you could write 4 high bits with -^^^, now you must use -^^^^. I feel this is more consistent with the operation of the other modes.\nUART Bus: UART, MIDI (universal asynchronous receiver transmitter). Connections: two pins (RX/TX) and ground. Output types: 3.3volt normal output, or open collector pull-up resistors required. Pull-up resistors: required for open collector output mode (2K – 10K). Maximum Voltage: 5.5volts (5volt safe). UART is also known as the common PC serial port. The PC serial port operates at full RS232 voltage levels (-13volts to +13volts) which are not compatible with the Buzzpirat.\nConfiguration options Speed (bps): 300, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 31250, BRG. Data bits and parity: 8/none, 8/even, 8/odd, 9/none. Stop bits: 1, 2. Receive polarity: idle 1, idle 0. Output type: open drain/open collector (high=Hi-Z, low=ground), normal (high=3.3volts, low=ground). Use open drain/open collector output types with pull-up resistors for multi-voltage interfacing. Syntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). [ Open UART, discard received bytes. { Open UART, display data as it arrives asynchronously. ] or } Close UART. r Check UART for byte, or fail if empty. Displays framing (-f) and parity (-p) errors (r:1…255 for bulk reads) 0b Write this binary value. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value. Format is 0×01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a coma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list ‘r’ read a byte UART mode requires special handling compared to the other Buzzpirat modes because data can arrive at any time. UART mode displays framing and parity errors, and automatically clears buffer overruns.\nParity and framing errors READ: -p -f 0×40 \u003c\u003c\u003c-p -f flag set The Buzzpirat reports framing errors (-f) and parity errors (-p) when reading a byte from the UART. It’s unlikely you’ll see these errors unless the UART speed is mismatched with the sender.\nBuffer overrun errors The Buzzpirat hardware has a four-byte UART buffer that holds data until you read it with an ‘r’ command, or until it can be printed to the terminal if live display is enabled with ‘[’. After it fills, new data will be lost. This is called a buffer overrun.\nREAD: 0x40 *Bytes dropped*\u003c\u003c\u003cbytes dropped error The Buzzpirat detects buffer errors, clears them, and alerts you of dropped bytes. The overrun bit is cleared any time you use the r, {, or [commands. If you close the live UART display (]) and more than 5 bytes come in, the next read command (r) will clear the error and print the bytes dropped warning.\nPrevent buffer problems by reducing the amount of data the Buzzpirat transfers over USB for each byte of UART data. Raw display mode reduces the four byte hex value 0×00 to a single raw byte value. A better way is to use macro (1) or (2) to view unformatted UART output, this is a 1:1 transfer of bytes that should work at the highest possible speeds.\nCustom baud rate A custom baud rate is set with the BRG option. Use a PIC UART calculator to find the correct value.\nSet the calculator with the Buzzpirat values: PIC24, 32MHz clock. Enter the desired baud rate and hit calculate. Use the value from the BRGH=1 section. For 9700bps enter 411 at the Buzzpirat BRG prompt.\nMacros Command Description 0 Macro menu 1 Transparent UART bridge. Reset to exit. 2 Live raw UART monitor. Any key exits. 3 Transparent UART bridge with flow control. Transparent UART bridge UART\u003e(1)\u003c\u003c\u003cmacro 1, transparent UART bridge UART bridge. Space continues, anything else exits. Reset to exit. The transparent UART mode macro (1) creates a simple serial-\u003eUSB bridge. The only way to exit this mode is to reset the Buzzpirat hardware.\nBuffer overrun errors that occur during bridge mode are automatically cleared so that data continues as normal (firmware v3.0+). The MODE LED will turn off to alert you of the buffer overrun error.\nMacro (3) is a second UART bridge mode that includes the CTS and RTS flow control signals. CTS is on the CS pin (PIC input from external circuit is passed to FTDI USB-\u003eserial chip). RTS is on the CLOCK pin (PIC output mirrors output from FTDI chip).\nNote that the Buzzpirat serial port UART facing the computer (the one that connects to the USB-\u003eserial converter chip and sends text to your computer) is NOT adjusted to the same speed as the UART bridge. The USB-side serial port UART will continue to operate at the default setting (115200bps) unless adjusted with the ‘b’ menu.\nIf you use the UART bridge with a computer program that opens the virtual serial port at a different baud rate, say 9600bps, the exchange will be garbled because the Buzzpirat expects 115200bps input from the computer. Adjust the computer-side serial speed first with the ‘b’ menu, then start the serial bridge at the desired speed.\nLive UART monitor UART\u003e(2)\u003c\u003c\u003cmacro 2, UART monitor Raw UART input. Space to exit. UART\u003e The UART monitor macro (2) shows a live display of UART input as raw byte values without any type of formatting. Press any key to exit the live monitor. This mode works best with a terminal that can display raw byte values in a variety of formats.\nThis macro is like the transparent UART macro (1) but without transmission abilities, and it can be exited with a key press. It’s useful for monitoring high-speed UART input that causes buffer overrun errors in other modes.\nMIDI MIDI is a command set used by electronic (music) instruments. It travels over a standard serial UART configured for 31250bps/8/n/1. Since firmware v2.7 MIDI is a speed option in the UART library.\nMIDI is a ring network, each node has an input and output socket. Each node passes messages to the next in the ring. The input and outputs are opto-isolated. The signaling is at 5volts, 5ma (current-based signaling). An adapter is required.\nConnections Connect the Buzzpirat transmit pin (TX/MOSI) to the UART device receive pin (RX). Connect the Buzzpirat receive pin (RX/MISO) to the UART device transmit pin (TX).\nFor macros and modes with flow control: CTS is on the CS pin (PIC input from external circuit is passed to FTDI USB-\u003eserial chip). RTS is on the CLOCK pin (PIC output mirrors output from FTDI chip)\nI2C Bus: I2C (eye-squared-see or eye-two-see) Connections: two pins (SDA/SCL) and ground Output types: open drain/open collector Pull-up resistors: pull-ups always required (2K - 10K ohms) Maximum voltage: 5.5volts (5volt safe) I2C is a common 2-wire bus for low speed interfaces.\nI2C implementation does not currently support clock stretching.\nConfiguration options Speed: I2C has three speed options:~50kHz, ~100kHz, and ~400kHz. HiZ\u003em\u003c\u003c\u003copen the mode menu 1. HiZ … 4. I2C … (1) \u003e4\u003c\u003c\u003cchoose I2C mode Set speed: 1. 50KHz 2. 100KHz 3. 400kHz (1) \u003e1\u003c\u003c\u003cchoose I2C speed I2C READY I2C\u003e Pull-up resistors I2C is an open-collector bus, it requires pull-up resistors to hold the clock and data lines high and create the data ‘1’. I2C parts don’t output high, they only pull low, without pull-up resistors there can never be a ‘1’. This will cause common errors such as the I2C address scanner reporting a response at every address. Read more about open drain/open collector bus types, and the Buzzpirat’s on-board pull-up resistors.\nI2C requires pull-up resistors to hold the clock and data lines high. I2C parts don’t output high, they only pull low. Without pull-up resistors there can never be a ‘1’.\nSyntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). { or [ Issue I2C start condition. ] or } Issue I2C stop condition. r Read one byte, send ACK. (r:1…255 for bulk reads) 0b Write this binary value, check ACK. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value, check ACK. Format is 0×01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value, check ACK. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a coma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Macro Command Description 0 Macro menu 1 7bit address search. Find all connected devices by brute force. 2 I2C snooper (alpha testing, unlisted) v2.1+ I2C address search scanner macro You can find the I2C address for most I2C-compatible chips in the datasheet. But what if you’re working with an unknown chip, a dated chip with no datasheet, or you’re just too lazy to look it up?\nThe Buzzpirat has a built-in address scanner that checks every possible I2C address for a response. This brute force method is a fast and easy way to see if any chips are responding, and to uncover undocumented access addresses.\nI2C chips respond to a 7bit address, so up to 128 devices can share the same two communication wires. An additional bit of the address determines if the operation is a write to the chip (0), or a read from the chip (1).\nI connected the Buzzpirat to the 3EEPROM explorer board. The 7bit base address for the 24LC/AA I2C EEPROM is 101 0000 (0x50 in HEX). It answers at the write address 1010 0000 (0xA0) and the read address 1010 0001 (0xA1).\nI2C\u003e(1) Searching 7bit I2C address space. Found devices at: 0xA0(0x50 W) 0xA1(0x50 R) I2C\u003e Macro 1 in the I2C library runs the address scanner. The scanner displays the raw addresses the chip acknowledged (0xA0, 0xA1), and the 7bit address equivalent (0x50) with write or read bit indicators (W/R). Datasheets usually list the 7bit address, but the 8bit value is more recognizable on a logic analyzer, snooper, debugger, etc.\nI2C\u003e (1) Searching I2C address space. Found devices at: Warning: *Short or no pull-up I2C\u003e The scanner will find a chip at every address if there’s no pull-up resistors on the I2C bus. This is a really common error. the scanner checks for pull-ups, and exits with an error if the bus isn’t pulled up.\nScanner details Details about the address scanner macro are at the end of this post and around here in the source.\nFor I2C write addresses: the BP sends a start, the write address, looks for an ACK, then sends a stop.\nFor I2C read addresses: the BP sends a start, the read address, looks for an ACK. If there is an ACK, it reads a byte and NACKs it. Finally it sends a stop.\nWhen the I2C chip responds to the read address, it outputs data and will miss a stop condition sent immediately after the read address (bus contention). If the I2C chip misses the stop condition, the address scanner will see ghost addresses until the read ends randomly. By reading a byte after any read address that ACKs, I have a chance to NACK the read and properly end the I2C transaction.\nI2C Bus Sniffer macro The I2C sniffer is implemented in software and seems to work up to 100kHz (firmware v5.3+). It’s not a substitute for a proper logic analyzer, but additional improvements are probably possible.\n[/] – Start/stop bit +/- – ACK/NACK I2C start and stop bits are represented by the normal Buzzpirat syntax.\nI2C\u003e (2) Sniffer Any key to exit [0x40-][0x40-0x40-0x30-0x56-0x77-] I2C\u003e Sniffed data values are always HEX formatted in user mode. Press any key to exit the sniffer.\nNotes The sniffer uses a 4096byte output ring buffer. Sniffer output goes into the ring buffer and gets pushed to the PC when the UART is free. This should eliminate problems with dropped bytes, regardless of UART speed or display mode. A long enough stream of data will eventually overtake the buffer, after which bytes are dropped silently (will be updated after v5.3).\nAny commands entered after the sniffer macro will be lost.\nPins that are normally output become inputs in sniffer node. MOSI and CLOCK are inputs in I2C sniffer mode.\nThe I2C sniffer maximum speed is around 100kHz.\nACK/NACK management These examples read and write from the RAM of a DS1307 RTC chip.\nI2C\u003e [0xd1 rrrr] I2C START CONDITION WRITE: 0xD1 GOT ACK: YES\u003c\u003c\u003cread address READ: 0×07 ACK \u003c\u003c\u003csent ACK[ READ: 0x06 ACK READ: 0x05 ACK READ: 0x04 NACK \u003c\u003c\u003clast read before STOP, sent NACK I2C STOP CONDITION I2C\u003e I2C read operations must be ACKed or NACKed by the host (the Buzzpirat). The Buzzpirat automates this, but you should know a few rules about how it works.\nThe I2C library doesn’t ACK/NACK a read operation until the following command. If the next command is a STOP (or START) the Buzzpirat sends a NACK bit. On all other commands it sends an ACK bit. The terminal output displays the (N)ACK status.\nI2C\u003e [0xd1 r:5] I2C START CONDITION WRITE: 0xD1 GOT ACK: YES BULK READ 0×05 BYTES: 0×07 ACK 0×06 ACK 0×05 ACK 0×04 ACK 0×03 NACK I2C STOP CONDITION I2C\u003e Nothing changes for write commands because the slave ACKs to the Buzzpirat during writes. Here’s an example using the bulk read command (r:5).\nI2C\u003e[0xd1 r \u003c\u003c\u003csetup and read one byte I2C START CONDITION WRITE: 0xD1 GOT ACK: YES READ: 0x07 *(N)ACK PENDING \u003c\u003c\u003cno ACK sent yet I2C\u003er\u003c\u003c\u003cread another byte ACK \u003c\u003c\u003cACK for previous byte READ: 0x06 *(N)ACK PENDING \u003c\u003c\u003cno ACK yet I2C\u003e] \u003c\u003c\u003cSTOP command NACK \u003c\u003c\u003cnext command is STOP, so NACK I2C STOP CONDITION I2C\u003e A consequence of the delayed ACK/NACK system is that partial transactions will leave read operations incomplete.\nHere, I setup a read operation ([0xd1) and read a byte (r). Since the Buzzpirat has no way of knowing if the next operation will be another read (r) or a stop condition (]), it leaves the ninth bit hanging. The warning “*(N)ACK PENDING” alerts you to this state.\nOur next command is another read (r), so the Buzzpirat ACKs the previous read and gets another byte. Again, it leaves the (N)ACK bit pending until the next command.\nThe final command is STOP (]). The Buzzpirat ends the read with a NACK and then sends the stop condition.\nConnections Buzzpirat Dir. Circuit Description MOSI ↔ SDA Serial Data CLK → SCL Serial Clock GND ⏚ GND Signal Ground SPI Bus: SPI (serial peripheral interface). Connections: Four pins (MOSI/MISO/CLOCK/CS) and ground. Output type: 3.3 volt normal, or open collector pull-up resistors required. Pull-up resistors: Required for open drain output mode (2K – 10K). Maximum voltage: 5.5 volts (5 volt safe). Last documentation update: v5.8. Configuration options Speed: 30, 125, 250 kHz; 1, 2, 2.6, 4, 8 MHz Clock polarity: Idle low, idle high. Output clock edge: Idle to active, active to idle. Input sample phase: Middle, end. Output type: Open drain/open collector (high=Hi-Z, low=ground), normal (high=3.3 volts, low=ground). Use open drain/open collector output types with pull-up resistors for multi-voltage interfacing. Syntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). [ Chip select (CS) active (low). { CS active (low), show the SPI read byte after every write. ] or } CS disable (high). r Read one byte by sending dummy byte (0xff). (r:1…255 for bulk reads) 0b Write this binary value. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value. Format is 0x01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a comma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Macro Command Description 0 Macro menu 1 SPI bus sniffer, sniff when CS is low (hardware CS filter) 2 SPI bus sniffer, sniff all traffic (no CS filter) 3 SPI bus sniffer, sniff when CS is high (software CS filter) Temporarily removed to increase speed. 10 Change clock polarity to 0 without re-entering SPI mode 11 Change clock polarity to 1 without re-entering SPI mode 12 Change clock edge to 0 without re-entering SPI mode 13 Change clock edge to 1 without re-entering SPI mode 14 Change sample phase to 0 without re-entering SPI mode 15 Change sample phase to 1 without re-entering SPI mode SPI Bus sniffer The Buzzpirat can read the traffic on an SPI bus.\nWarning! Enter sniffer mode before connecting the target!! The Buzzpirat SPI CLOCK or DATA lines could be grounded and ruin the target device! Reset with the CS pin to clear garbage if needed\nPin connections are the same as normal SPI mode. Connect the Buzzpirat clock to the clock on the SPI bus you want to sniff. The data pins MOSI and MISO are both inputs, connect them to the SPI bus data lines. Connect the CS pin to the SPI bus CS pin.\n[/] – CS enable/disable 0xXX – MOSI read (0xXX) – MISO read SPI CS pin transitions are represented by the normal Buzzpirat syntax. The byte sniffed on the MISO pin is displayed inside ().\nSPI\u003e (0) 0.Macro menu 1.Sniff CS low 2.Sniff all traffic SPI\u003e (1) Sniffer Any key to exit [0x30(0x00)0xff(0x12)0xff(0x50)][0x40(0x00)] The SPI sniffer can read all traffic, or filter by the state of the CS pin. The byte sniffed on the MOSI pin is displayed as a HEX formatted value, the byte sniffed on the MISO pin is inside the ().\nThere may be an issue in the sniffer terminal mode from v5.2+. Try the binary mode sniffer utility for best results. Notes\nThe sniffer uses a 4096byte output ring buffer. Sniffer output goes into the ring buffer and gets pushed to the PC when the UART is free. This should eliminate problems with dropped bytes, regardless of UART speed or display mode.\nWarning! Enter sniffer mode before connecting the target!! The Buzzpirat SPI CLOCK or DATA lines could be grounded and ruin the target device! Reset with the CS pin to clear garbage if needed\nA long enough stream of data will eventually overtake the buffer, after which the MODE LED turns off (v5.2+). No data can be trusted if the MODE LED is off - this will be improved in a future firmware. The SPI hardware has a 4 byte buffer. If it fills before I can transfer the data to the ring buffer, then the terminal will display “Can’t keep up” and drop back to the SPI prompt. This error and the ring buffer error will be combined in a future update. Any commands entered after the sniffer macro will be lost. Pins that are normally output become inputs in sniffer mode. MOSI, CLOCK, MISO, and CS are all inputs in SPI sniffer mode. Since v5.3 the SPI sniffer uses hardware chip select for the CS low sniffer mode. The minimum time between CS falling and the first clock is 120ns theoretical, and less than 1.275us in tests. The software CS detect (CS high sniffer mode) requires between 27usec and 50usec minimum delay between the transition of the CS line and the start of data. Thanks to Peter Klammer for testing and updates. The sniffer follows the output clock edge and output polarity settings of the SPI mode, but not the input sample phase. Clock edge/clock polarity/sample phase macros Macros 10-15 change SPI settings without disabling the SPI module. These macros were added at a user’s request, but they never reported if it worked.\nSPI\u003e (10)(11)(12)(13)(14)(15) SPI (spd ckp ske smp csl hiz)=( 3 0 1 0 1 1 ) SPI (spd ckp ske smp csl hiz)=( 3 1 1 0 1 1 ) SPI (spd ckp ske smp csl hiz)=( 3 1 0 0 1 1 ) SPI (spd ckp ske smp csl hiz)=( 3 1 1 0 1 1 ) SPI (spd ckp ske smp csl hiz)=( 3 1 1 0 1 1 ) SPI (spd ckp ske smp csl hiz)=( 3 1 1 1 1 1 ) SPI\u003e Connections Buzzpirat Dir. Circuit Description MOSI → MOSI Master Out, Slave In MISO ← MISO Master In, Slave Out CS → CS Chip Select CLK → CLK Clock signal GND ⏚ GND Signal Ground Raw 2-wire Bus: General purpose 2-wire library with bitwise pin control. Connections: Two pins (SDA/SCL) and ground. Output type: 3.3 volt normal, or open collector pull-up resistors required. Pull-up resistors: Required for open drain output mode (2K – 10K). Maximum voltage: 5.5 volts (5 volt safe). Last documentation update: v5.6. The raw 2 wire library is similar to I2C, but it doesn’t handle acknowledge bits and it has bitwise pin control. I2C could be built using the basic elements in the raw2wire library.\nConfiguration options Speed: High (~50kHz) and low (~5kHz). Output type: Open drain/open collector (high=Hi-Z, low=ground), normal (high=3.3 volts, low=ground). Use open drain/open collector output types with pull-up resistors for multi-voltage interfacing. Syntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). { or [ Issue I2C-style start condition. ] or } Issue I2C-style stop condition. r Read one byte. (r:1…255 for bulk reads) 0b Write this binary value. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value. Format is 0×01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a comma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Bitwise ^ Send one clock tick. (^:1…255 for multiple clock ticks) / or \\ Toggle clock level high (/) and low (\\). Includes clock delay (100uS). - or _ Toggle data state high (-) and low (_). Includes data setup delay (20uS). ! Read one bit with clock. . Read data pin state (no clock). Macro Command Description 0 Macro menu 1 ISO7813-3 ATR for smart cards, parses reply bytes. 2 ISO7813-3 parse only (provide your own ATR command). Connections Buzzpirat Dir. Circuit Description MOSI ↔ SDA Serial Data CLK → SCL Serial Clock GND ⏚ GND Signal Ground Raw 3-wire Bus: General purpose 3-wire library with bitwise pin control. Connections: Four pins (MOSI/MISO/CLOCK/CS) and ground. Output types: 3.3 volt normal, or open drain/open collector pull-up resistors required. Pull-up resistors: Required for open drain output mode (2K – 10K). Maximum voltage: 5.5 volts (5 volt safe). Last documentation update: v5.6. The raw 3 wire library is like SPI, but includes bitwise pin control.\nConfiguration options Speed: High (~50kHz) and low (~5kHz). Output type: Open drain/open collector (high=Hi-Z, low=ground), normal (high=3.3 volts, low=ground). Use open drain/open collector output types with pull-up resistors for multi-voltage interfacing. Syntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). [ Chip select (CS) active (low). { CS active (low), show the SPI read byte after every write. ] or } CS disable (high). r Read one byte by sending dummy byte (0xff). (r:1…255 for bulk reads) 0b Write this binary value. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value. Format is 0x01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a comma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Bitwise ^ Send one clock tick. (^:1…255 for multiple clock ticks) / or \\ Toggle clock level high (/) and low (\\). Includes clock delay (100uS). - or _ Toggle data state high (-) and low (_). Includes data setup delay (20uS). ! Read one bit with clock. . Read data pin state (no clock). Connections Buzzpirat Dir. Circuit Description MOSI → MOSI Master Out, Slave In MISO ← MISO Master In, Slave Out CS → CS Chip Select CLK → CLK Clock signal GND ↔ GND Signal Ground HD44780 LCDs Bus: HD44780 LCD test library. Adapter: 74HCT595-based LCD adapter board The Buzzpirat can test HD44780 LCDs but it needs an IO expander chip. Currently, it uses a simple 74HCT595 adapter\nSyntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). { or [ RS low. Next read/write is a COMMAND. ] or } RS high. Next read/write is TEXT/DATA. r Read one byte (r:1…255 for bulk reads). 0b Write this binary value. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value. Format is 0x01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value. Any number not preceded by 0x or 0b is interpreted as a decimal value. \"xxx\" Write the ASCII text xxx to the LCD. , Value delimiter. Use a comma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Macro Command Description 0 Macro menu 1 LCD reset. 2 Init LCD. 3 Clear LCD. 4 Cursor position ex: (4:0). 5 Write test text. (deprecated) 6 Write :number test numbers ex: (6:80). 7 Write :number test characters ex: (7:80). PC keyboard Bus: PC keyboard interface library. Connections: Two pins (KBD/KBC) and ground. Output type: Open drain/open collector. Pull-up resistors: None, keyboard has internal pull-ups. Maximum voltage: 5 volts. This library interfaces PC keyboards. A PC keyboard operates at 5 volts and has its own internal pull-up resistors to 5 volts. The keyboard issues a clock signal that drives all transactions, the library includes a time-out (v0h+) so the Buzzpirat won’t freeze if the keyboard doesn’t respond.\nSyntax Command Description A/a/@ Toggle auxiliary pin. Capital “A” sets AUX high, small “a” sets to ground. @ sets aux to input (high impedance mode) and reads the pin value. D/d Measure voltage on the ADC pin (v1+ hardware only). W/w Capital ‘W’ enables the on-board power supplies. Small ‘w’ disables them. (v1+ hardware only). r Read one byte with timeout. (r:1…255 for bulk reads) 0b Write this binary value with timeout. Format is 0b00000000 for a byte, but partial bytes are also fine: 0b1001. 0x Write this HEX value with timeout. Format is 0x01. Partial bytes are fine: 0xA. A-F can be lower-case or capital letters. 0-255 Write this decimal value with timeout. Any number not preceded by 0x or 0b is interpreted as a decimal value. , Value delimiter. Use a comma or space to separate numbers. Any combination is fine, no delimiter is required between non-number values: {0xa6,0, 0 16 5 0b111 0xaF}. \u0026 Delay 1uS. (\u0026:1…255 for multiple delays) (#) Run macro, (0) for macro list Macro Command Description 0 Macro menu 1 Live keyboard monitor (v0h+) DIO This mode gives the user 100% control over the Buzzpirat IO pins from the terminal.\nSend same command values as the binary bitbang mode to set pin direction and state.\nBASIC script reference BASIC script mode is entered by typing ’s’ at the Buzzpirat commandline. You need to take care of entering the correct mode and set it up (things like speed, Hiz, etc.).\nThis isn’t intended as a guide in learning how to program. General programming knowledge is assumed. Be aware that only basic checking is done and there are no warnings printed to the terminal (except those intended by the program with print statements). The editor is very rudimentary and does not check if the syntax is right. The language is loosely based on BASIC.\nEnter script mode:\nHiZ\u003e s HiZ(BASIC)\u003e NEW The memory is cleared by entering the NEW command.\nHiZ(BASIC)\u003e new Ready. HiZ(BASIC)\u003e NOTE: With firmware before version 5.8 this command was mandatory before entering anything else in the basic editor!!\nLIST From the basic commandline programs can be entered. The basicinterpreter uses linenumbers followed by statements. After this the program can be listed by the command ‘LIST’\nHiZ(BASIC)\u003e list 100 REM BASICDEMO 110 PRINT \"HELLO WORLD!\" 120 PRINT \"HELLO AGAIN\" 65535 END 52 bytes. Ready. HiZ(BASIC)\u003e RUN You can also run it with the command run:\nHiZ(BASIC)\u003e run HELLO WORLD! HELLO AGAIN Ready. HiZ(BASIC)\u003e Variables A..Z (26) variables are possible. The variable are internally 16bit signed\nLET assigns a variable. Another variable, constants or functions that returns a value (e.g. RECEIVE)\n10 LET A=B+1 IF {ifstat} THEN {truestat} ELSE {falsestat} Evaluate the {ifstat} if it evaluate to a value that is not zero {truestat} get executed otherwise {falsestat}.\n10 IF A=1 THEN GOTO 100 ELSE PRINT \"A IS NOT 1\" GOTO {line} jumps to line {line}, without remembering where it came from (see also GOSUB)\n10 GOTO 100 20 PRINT \"line 20\" 100 PRINT \"line 100\" line 20 doesn’t get executed\nGOSUB {line} and RETURN jumps to line {line}, executes from there till a RETURN and return to the line after the GOSUB.\n10 GOSUB 1000 20 PRINT \"line 20\" 30 END 1000 PRINT \"line 1000\" 1010 RETURN Stack is 10 levels deep, so 10 nested gosubs are possible.\nREM {text} Puts a remark into the code, but gets skipped.\n10 REM A WONDERFULL PROGRAM Don’t use REM between DATA statements!\nPRINT {text} Prints {text} to the terminal. Variable and statement can be mixed and are seperated with a ‘;’. A ‘;’ at the end suppresses a newline.\n10 PRINT \"A = \";A 20 PRINT \"RECEIVED: \";RECEIVE 30 PRINT \"B = \"; 40 PRINT B INPUT {question},{var} Ask {question} and put the answer the user gave into {var}\n10 INPUT \"A = \",A FOR {var}={minvalue} TO {maxvalue} {stats} NEXT {var} Assigns value {minvalue} to variable {var}, executes statements {stats} until NEXT is encountered. Variable {var} wil be increased by one, {stats} is again executed, until {var} has the value {maxvalue}.\n10 FOR A=1 TO 10 20 PRINT \"A = \";A 30 NEXT A for/nexts can be nested 4 deep.\nREAD {var} \u0026 DATA {val1}, {val2}, .. {val1}, {val2}, Read a value into variable {var}. The values are stored in DATA statements.\n10 READ A 20 PRINT \"A = \";A 30 READ A 40 PRINT \"A = \";A 1000 DATA 10,20 START Same as the Buzzpirat ‘[’ command\n10 START STOP Same as the Buzzpirat ‘]’ command\n10 STOP STARTR Same as the Buzzpirat ‘{’ command\n10 STARTR STOPR Same as the Buzzpirat ‘}’ command\n10 STOPR SEND {val/var} Sends a value {val} or variable {var} over the bus.\n10 SEND 10 20 SEND A Some protocols send/receive at the same time. This is also possible:\n10 LET A=SEND 100 20 PRINT \"SEND 100 GOT \";A RECEIVE Receives data from the bus. With some protocols it returns value \u003e255 to signal busstates (like no data, got ACK, etc), other protocols are 16 bit (like pic).\n10 LET A=RECEIVE 20 PRINT \"A = \";A CLK {val} Controls the CLK line, its behaviour depends on val; 0=low, 1=high, 2=pulse.\n10 CLK 2 DAT {val} Controls the DAT line, its behaviour depends on val; 0=low, 1=high.\n10 DAT 0 DAT value can also be read:\n10 LET A=DAT 20 PRINT \"A = \";A BITREAD Same as the Buzzpirat ‘!’ command.\n10 LET A=BITREAD 20 PRINT \"A = \";A ADC Reads the ADC. Value returned is 10bits (no conversion!).\n10 LET A=ADC 20 PRINT \"A = \";A AUX {val} Controls the AUX line, its behaviour depends on val; 0=low, 1=high.\n10 AUX 1 AUX value can also be read:\n10 LET A=AUX 20 PRINT \"A = \";A AUXPIN {val} Controls which pin is controlled by the AUX statement; 0=AUX; 1=CS\n10 AUXPIN 1 PSU {val} Controls the onboard voltage regulators; 0=off, 1=on\n10 PSU 1 PULLUP {val} Controls the onboard pullup resistors; 0=off, 1=on\n10 PULLUP 0 DELAY {var} Delays {var} ms\n10 DELAY 100 FREQ {var} \u0026 DUTY {var} Controls the onboard PWM generator. Frequency of 0 disables it. (same limits apply as regular PWM command (‘g’))\n10 freq 100 20 duty 25 ","categories":"","description":"How to use your Buzzpirat mod from dangerousprototypes","excerpt":"How to use your Buzzpirat mod from dangerousprototypes","ref":"/docs/how-to-use/","tags":"","title":"How to use"},{"body":"Have you tried updating the bootloader of Buzzpirat or Bus Pirate v3 and it doesn’t work? Doesn’t it even enter bootloader mode when bridging the PGD and PGC pins? Don’t worry, there are several ways to fix it.\nUnbrick using another Bus Pirate v3 Downgrade your Bus Pirate v3 firmware Connect to the Bus Pirate v3 to Bricked Buzzpirat / Bricked Bus Pirate v3 Burn a new bootloader and firmware to the bricked device Unbrick using clones like PICkit3.5 Unbrick using official MPLAB PICkit 5 Unbrick using another Bus Pirate v3 The Bus Pirate v3 can be used as an inexpensive PIC programmer.\nTotal cost: ~40$\nBuy a Bus Pirate v3 + USB mini -\u003e USB A cable Buy 5 dupont cables FEMALE-FEMALE Downgrade your Bus Pirate v3 firmware Warning You must install this version because the picprog program only works with certain firmwares. Download BPv3-Firmware-v5.9-extras.hex firmware from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/oldfirm Download the last buzzloader app (There are versions available for Windows, Linux and Mac) from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/buzzloader\nput a jumper/dupont_wire connecting the PGD pin to the PGC pin\nconnect the Bus Pirate v3 to your computer via a usb cable\ncheck for the new COM port assignment in the device manager (e.g., COM29)\nMake sure to close Tera Term or any other software that might be using the COM port to free it up and execute:\nbuzzloader.exe --dev=COM29 --hex=BPv3-Firmware-v5.9-extras.hex Erasing page 41, a400...OK Writing page 41 row 328, a400...OK Writing page 41 row 329, a480...OK Writing page 41 row 330, a500...OK Writing page 41 row 331, a580...OK Writing page 41 row 332, a600...OK Writing page 41 row 333, a680...OK Writing page 41 row 334, a700...OK Writing page 41 row 335, a780...OK Firmware updated successfully :)! Use screen com30 115200 to verify Remove the jumper/Dupont cable, then reconnect the device to the USB port, and you’re all set! You should now have the firmware installed.\nRun the ‘i’ command and perform a self-test with the ‘~’ command to ensure everything has gone smoothly.\ni Bus Pirate v3b Firmware v5.9 (r529) [HiZ 2WIRE 3WIRE KEYB LCD DIO] Bootloader v4.5 DEVID:0x0447 REVID:0x3046 (24FJ64GA002 B8) http://dangerousprototypes.com HiZ\u003e Connect to the Bus Pirate v3 to Bricked Buzzpirat / Bricked Bus Pirate v3 Locate the PIC programming pins on the bricked device. Look for the pin named: MCLR.\nConnect the pins using Dupont cables in the following manner:\nBus Pirate v3 Bricked device CLK PGC MOSI PGD GND GND +3v3 +3v3 CS MCLR Burn a new bootloader and firmware to the bricked device Warning Download the firmware labeled with “pickit” in its name If you are unbricking a Buzzpirat. Download the last bootloader + firmware .hex file from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/stablefirm If you are unbricking a Bus Pirate v3. Download the last bootloader + firmware .hex file from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/stablefirm/bpv3comp Download the last picprog app from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/picprog Ensure that both the bricked device and the Bus Pirate v3 are connected to the PC via USB\nMake sure to close Tera Term or any other software that might be using the COM port to free it up and execute: (my Bus Pirate v3 is on COM29):\npicprog.exe -p buspirate -u COM29 -s 115200 -c 24FJ64GA002 -t HEX -w BZ-pickit-firmware-v7.1.6969-bootloader-v4.5.hex -E Skipping page 333 [ 0x014d00 ], not used Skipping page 334 [ 0x014e00 ], not used Writing page 335, 14f00... Writing page 336, 15000... Writing page 337, 15100... Writing page 338, 15200... Writing page 339, 15300... Skipping page 340 [ 0x015400 ], not used Skipping page 341 [ 0x015500 ], not used Skipping page 342 [ 0x015600 ], not used Writing page 343, 15700... Remove the Dupont cables from MCLR, PGD, PGC, GND, +3v3 pins, then reconnect the bricked device to the USB port, and you’re all set! You should now have the bootloader+firmware installed.\nRun the ‘i’ command and perform a self-test with the ‘~’ command to ensure everything has gone smoothly.\nHiZ\u003ei Bus Pirate v3.5 Community Firmware v7.1 - buzzpirat.com by Dreg BZ SIXTHOUSANDNINEHUNDREDSIXTYNINE [HiZ 1-WIRE UART I2C SPI 2WIRE 3WIRE KEYB LCD PIC DIO] Bootloader v4.5 DEVID:0x0447 REVID:0x3046 (24FJ64GA00 2 B8) http://dangerousprototypes.com HiZ\u003e Now, reinstall the latest firmware on your Bus Pirate v3 (the one you used as a PIC programmer).\nUnbrick using clones like PICkit3.5 Buy a PICkit3.5 from Aliexpress (an inexpensive PIC programmer).\nTotal cost: ~30$\nDownload \u0026 install the last pickit minus app from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/pickitminus If you are unbricking a Buzzpirat. Download the last bootloader + firmware .hex file from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/stablefirm If you are unbricking a Bus Pirate v3. Download the last bootloader + firmware .hex file from this page:\nhttps://github.com/therealdreg/buzzpirat/tree/main/bin/stablefirm/bpv3comp Connect Buzzpirat / Bus Pirate pins to the pins located furthest to the right of the Pickit:\nConnect Buzzpirat / Buspirate \u0026 Pickit to PC USB\nOpen the pickitminus app\nGo to Tools -\u003e Download PICkit Operating System\nMake sure the PIC has been detected: PIC DEVICE FOUND, PIC24FJ64GA002\nSelect .hex for pickit minus use\nGo to File -\u003e Import Hex\nAnd select the Buzzpirat / Buspirate “bootloader + firmware” .hex file (with pickit in its name, example: BZ-pickit-firmware-v7.1.9-bootloader-v4.5.hex)\nClick on Write\nDone!\nDisconnect Buzzpirat / Buspirate \u0026 Pickit from PC USB\nUnbrick using official MPLAB PICkit 5 Buy a PICkit 5 from Microchip.\nTotal cost: ~100$\nDownload \u0026 install the last MPLAB X IDE from this page:\nhttps://www.microchip.com/en-us/tools-resources/develop/mplab-x-ide\nConnect Buzzpirat / Bus Pirate pins to the pins located furthest to the right of the Pickit:\nConnect Buzzpirat / Buspirate \u0026 Pickit to PC USB\nOpen MPLAB IPE (included with MPLAB X IDE):\nSelect your Pickit Programmer, PIC24FJ64GA002\nAnd click on Connect, after that check that the PICKIT \u0026 PIC has been detected: PIC DEVICE FOUND, PIC24FJ64GA002:\nGo to Browse and select the Buzzpirat / Buspirate “bootloader + firmware” .hex file (with pickit in its name, example: BZ-pickit-firmware-v7.1.9-bootloader-v4.5.hex)\nAnd click on Program\nDone!\nDisconnect Buzzpirat / Buspirate \u0026 Pickit from PC USB\n","categories":"","description":"How to unbrick your Buzzpirat / Bus Pirate v3","excerpt":"How to unbrick your Buzzpirat / Bus Pirate v3","ref":"/docs/unbrick/","tags":"","title":"Unbrick"},{"body":"","categories":"","description":"","excerpt":"","ref":"/docs/","tags":"","title":"Documentation"},{"body":"Flashrom is a versatile utility for managing flash chips, capable of identifying, reading, writing, verifying, and erasing them. It’s particularly adept at flashing BIOS/EFI/coreboot/firmware/optionROM images on a variety of hardware, including mainboards, network/graphics/storage controllers, and other programmer devices.\nKey features include:\nSupport for over 476 flash chips, 291 chipsets, 500 mainboards, 79 PCI devices, 17 USB devices, and a range of programmers via parallel/serial ports. Compatibility with parallel, LPC, FWH, and SPI flash interfaces, and various chip packages like DIP32, PLCC32, DIP8, SO8/SOIC8, TSOP32, TSOP40, TSOP48, BGA, and more. Operable without physical access; root access is typically sufficient, with some programmers not requiring it. No need for bootable media, keyboard, or monitor; capable of remote flashing via SSH. Allows flashing within a running system with no immediate reboot required; the new firmware activates on the next boot. Supports crossflashing and hotflashing, given electrical and logical compatibility of flash chips. Scriptable for simultaneous flashing across multiple machines. Faster than many vendor-specific flash tools. Portable across various operating systems including DOS, Linux, FreeBSD, NetBSD, OpenBSD, DragonFlyBSD, Solaris-like systems, Mac OS X, and other Unix-like OSes, as well as GNU Hurd. Partial Windows support is available, excluding internal programmer support.\" Update Flashrom \u0026 Buzzpirat Flashrom supports Buzzpirat out of the box\nEnsure you have the latest stable firmware installed; learn how in the Firmware Update section.\nFinally, make sure to use the latest development version of flashrom or our mod:\nWindows mod: https://github.com/therealdreg/flashrom_build_windows_x64 mod code (For Unix): https://github.com/therealdreg/flashrom-dregmod Official repo: https://github.com/flashrom/flashrom Help A required dev parameter specifies the Buzzpirat device node and an optional spispeed parameter specifies the frequency of the SPI bus. The parameter delimiter is a comma. Syntax is:\nflashrom -p buspirate_spi:dev=/dev/device,spispeed=frequency where frequency can be 30k, 125k, 250k, 1M, 2M, 2.6M, 4M or 8M (in Hz). The default is the maximum frequency of 8 MHz.\nThe baud rate for communication between the host and the Buzzpirat can be specified with the optional serialspeed parameter. Syntax is:\nflashrom -p buspirate_spi:serialspeed=baud where baud can be 115200, 230400, 250000 or 2000000 (2M). The default is 2M baud.\nAn optional pullups parameter specifies the use of the Buzzpirat internal pull-up resistors. This may be needed if you are working with a flash ROM chip that you have physically removed from the board. Syntax is:\nflashrom -p buspirate_spi:pullups=state where state can be on or off.\nWhen working with low-voltage chips, the internal 10k pull-ups of the Buzzpirat might be too high. In such cases, it’s necessary to create an external pull-up using lower-value resistors.\nFor this, you can use the hiz parameter. This way, the Buzzpirat will operate as an open drain. Syntax is:\nflashrom -p buspirate_spi:hiz=state where state can be on or off.\nThe state of the Buzzpirat power supply pins is controllable through an optional psus parameter. Syntax is:\nflashrom -p buspirate_spi:psus=state where state can be on or off. This allows the Buzzpirat to power the ROM chip directly. This may also be used to provide the required pullup voltage (when using the pullups option), by connecting the Buzzpirat’s Vpu input to the appropriate Vcc pin.\nAn optional aux parameter specifies the state of the Buzzpirat auxiliary pin. This may be used to drive the auxiliary pin high or low before a transfer. Syntax is:\nflashrom -p buspirate_spi:aux=state where state can be high or low. The default state is high.\nTutorial Winbond 3v3 64M-BIT w25q64fv board This board is included in our full kit for practice purposes. You can purchase another one on Aliexpress, Amazon, or eBay.\nFor this case, simply use the official Buzzpirat cables with the female Dupont connector they come with; there’s no need to use SMD IC clips. Connect the Buzzpirat to the w25q64fv board by attaching the +3v3(SW3V3) to VCC, CS to CS, MISO to DO, GND to GND, CLK to CLK, and MOSI to DI, ensuring each connection is secure for proper functionality\nBuzzpirat w25q64fv board +3v3(SW3V3) VCC CS CS MISO DO GND GND CLK CLK MOSI DI To read the content of a flash memory chip using flashrom with Buzzpirat, execute the following command:\nflashrom.exe --progress -V -c \"W25Q64BV/W25Q64CV/W25Q64FV\" -p buspirate_spi:dev=COM8,spispeed=1M,serialspeed=115200 -r flash_content.bin --progress: This parameter shows the progress of the operation, providing visual feedback in the terminal. -V: Stands for ‘verbose’. It increases the verbosity of the program, providing detailed output about the operations being performed. This is useful for debugging or getting more information about the process. -c “W25Q64BV/W25Q64CV/W25Q64FV” in flashrom is used to specify the exact model of the flash chip that you intend to interact with. When you run flashrom without the -c parameter, the tool attempts to automatically detect the types of flash memory chips that are present in your system. -p buspirate_spi: Specifies the programmer type. In this case, it’s set to buspirate_spi, indicating that the Buzzpirat is used for SPI (Serial Peripheral Interface) programming. dev=COM8: This part of the parameter specifies the device name. COM8 refers to the COM port where the Buzzpirat is connected. This will vary depending on your system’s configuration. You can find the COM port number by opening the Device Manager in Windows and looking for the Bus Pirate device under the Ports (COM \u0026 LPT) section. spispeed=1M: Sets the SPI communication speed to 1 MHz. Adjusting the SPI speed can be necessary depending on the flash chip’s specifications and the quality of the connections. serialspeed=115200: Sets the serial communication speed (baud rate) between the computer and the Buzzpirat to 115200 bits per second. This is a common baud rate for serial communication. -r flash_content.bin: This part of the command tells flashrom to read the flash memory’s content and save it into a file named flash_content.bin The read operation may take about 15 minutes to complete. Once it’s done, you can use a hex editor / binwalk etc to open the flash_content.bin file and inspect its contents.\n","categories":"","description":"","excerpt":"Flashrom is a versatile utility for managing flash chips, capable of …","ref":"/docs/avrdude/","tags":"","title":"AVRDude"},{"body":"Flashrom is a versatile utility for managing flash chips, capable of identifying, reading, writing, verifying, and erasing them. It’s particularly adept at flashing BIOS/EFI/coreboot/firmware/optionROM images on a variety of hardware, including mainboards, network/graphics/storage controllers, and other programmer devices.\nKey features include:\nSupport for over 476 flash chips, 291 chipsets, 500 mainboards, 79 PCI devices, 17 USB devices, and a range of programmers via parallel/serial ports. Compatibility with parallel, LPC, FWH, and SPI flash interfaces, and various chip packages like DIP32, PLCC32, DIP8, SO8/SOIC8, TSOP32, TSOP40, TSOP48, BGA, and more. Operable without physical access; root access is typically sufficient, with some programmers not requiring it. No need for bootable media, keyboard, or monitor; capable of remote flashing via SSH. Allows flashing within a running system with no immediate reboot required; the new firmware activates on the next boot. Supports crossflashing and hotflashing, given electrical and logical compatibility of flash chips. Scriptable for simultaneous flashing across multiple machines. Faster than many vendor-specific flash tools. Portable across various operating systems including DOS, Linux, FreeBSD, NetBSD, OpenBSD, DragonFlyBSD, Solaris-like systems, Mac OS X, and other Unix-like OSes, as well as GNU Hurd. Partial Windows support is available, excluding internal programmer support.\" Update Flashrom \u0026 Buzzpirat Flashrom supports Buzzpirat out of the box\nEnsure you have the latest stable firmware installed; learn how in the Firmware Update section.\nFinally, make sure to use the latest development version of flashrom or our mod:\nWindows mod: https://github.com/therealdreg/flashrom_build_windows_x64 mod code (For Unix): https://github.com/therealdreg/flashrom-dregmod Official repo: https://github.com/flashrom/flashrom Help A required dev parameter specifies the Buzzpirat device node and an optional spispeed parameter specifies the frequency of the SPI bus. The parameter delimiter is a comma. Syntax is:\nflashrom -p buspirate_spi:dev=/dev/device,spispeed=frequency where frequency can be 30k, 125k, 250k, 1M, 2M, 2.6M, 4M or 8M (in Hz). The default is the maximum frequency of 8 MHz.\nThe baud rate for communication between the host and the Buzzpirat can be specified with the optional serialspeed parameter. Syntax is:\nflashrom -p buspirate_spi:serialspeed=baud where baud can be 115200, 230400, 250000 or 2000000 (2M). The default is 2M baud.\nAn optional pullups parameter specifies the use of the Buzzpirat internal pull-up resistors. This may be needed if you are working with a flash ROM chip that you have physically removed from the board. Syntax is:\nflashrom -p buspirate_spi:pullups=state where state can be on or off.\nWhen working with low-voltage chips, the internal 10k pull-ups of the Buzzpirat might be too high. In such cases, it’s necessary to create an external pull-up using lower-value resistors.\nFor this, you can use the hiz parameter. This way, the Buzzpirat will operate as an open drain. Syntax is:\nflashrom -p buspirate_spi:hiz=state where state can be on or off.\nThe state of the Buzzpirat power supply pins is controllable through an optional psus parameter. Syntax is:\nflashrom -p buspirate_spi:psus=state where state can be on or off. This allows the Buzzpirat to power the ROM chip directly. This may also be used to provide the required pullup voltage (when using the pullups option), by connecting the Buzzpirat’s Vpu input to the appropriate Vcc pin.\nAn optional aux parameter specifies the state of the Buzzpirat auxiliary pin. This may be used to drive the auxiliary pin high or low before a transfer. Syntax is:\nflashrom -p buspirate_spi:aux=state where state can be high or low. The default state is high.\nTutorial Winbond 3v3 64M-BIT w25q64fv board This board is included in our full kit for practice purposes. You can purchase another one on Aliexpress, Amazon, or eBay.\nFor this case, simply use the official Buzzpirat cables with the female Dupont connector they come with; there’s no need to use SMD IC clips. Connect the Buzzpirat to the w25q64fv board by attaching the +3v3(SW3V3) to VCC, CS to CS, MISO to DO, GND to GND, CLK to CLK, and MOSI to DI, ensuring each connection is secure for proper functionality\nBuzzpirat w25q64fv board +3v3(SW3V3) VCC CS CS MISO DO GND GND CLK CLK MOSI DI To read the content of a flash memory chip using flashrom with Buzzpirat, execute the following command:\nflashrom.exe --progress -V -c \"W25Q64BV/W25Q64CV/W25Q64FV\" -p buspirate_spi:dev=COM8,spispeed=1M,serialspeed=115200 -r flash_content.bin --progress: This parameter shows the progress of the operation, providing visual feedback in the terminal. -V: Stands for ‘verbose’. It increases the verbosity of the program, providing detailed output about the operations being performed. This is useful for debugging or getting more information about the process. -c “W25Q64BV/W25Q64CV/W25Q64FV” in flashrom is used to specify the exact model of the flash chip that you intend to interact with. When you run flashrom without the -c parameter, the tool attempts to automatically detect the types of flash memory chips that are present in your system. -p buspirate_spi: Specifies the programmer type. In this case, it’s set to buspirate_spi, indicating that the Buzzpirat is used for SPI (Serial Peripheral Interface) programming. dev=COM8: This part of the parameter specifies the device name. COM8 refers to the COM port where the Buzzpirat is connected. This will vary depending on your system’s configuration. You can find the COM port number by opening the Device Manager in Windows and looking for the Bus Pirate device under the Ports (COM \u0026 LPT) section. spispeed=1M: Sets the SPI communication speed to 1 MHz. Adjusting the SPI speed can be necessary depending on the flash chip’s specifications and the quality of the connections. serialspeed=115200: Sets the serial communication speed (baud rate) between the computer and the Buzzpirat to 115200 bits per second. This is a common baud rate for serial communication. -r flash_content.bin: This part of the command tells flashrom to read the flash memory’s content and save it into a file named flash_content.bin The read operation may take about 15 minutes to complete. Once it’s done, you can use a hex editor / binwalk etc to open the flash_content.bin file and inspect its contents.\n","categories":"","description":"","excerpt":"Flashrom is a versatile utility for managing flash chips, capable of …","ref":"/docs/flashrom/","tags":"","title":"Flashrom"},{"body":" Thank you to everyone who collaborates with us and makes this project much better\nJuan M Martinez Casais R\u0026D Electronics k1m3rA logos \u0026 art Becca203 logos \u0026 art Ian Lesnet \u0026 Dangerous Prototypes Bus Pirate creator Rugged Circuits Security Ideas ","categories":"","description":"","excerpt":" Thank you to everyone who collaborates with us and makes this project …","ref":"/acknowledgements/","tags":"","title":"Acknowledgements"},{"body":" Buzzpirat: All-In-One Ruggedized Hardware Hacking tool for learning, practice and play Learn More Buy Our mission is to make hardware hacking knowledge accessible to people with limited understanding of hardware, electronics, and mathematics\nWe create tools, documentation, training, and audiovisual materials to help you learn and practice hardware hacking in a safe and legal environment\nUsing the same hardware as Bus Pirate v3 but with some enhancements\nRuggedized Ensuring the safety of three key components: the Buzzpirat device, the target chip, and the PC\nWe’ve implemented advanced hardware protections including overvoltage and overcurrent safeguards, reverse polarity protection, and various measures to prevent device damage.\nThis includes a PTC (Positive Temperature Coefficient) for each I/O, Zener diodes, cut-off circuitry, and more, to enhance overall security\nBluetooth and WiFi Compatible with Bluetooth/WiFi UART adapters for both iOS and Android, allowing for hardware hacking without the need for a PC\nThis functionality safeguards your computer by ensuring it remains disconnected from the target chip/board during incidents like short circuits, high voltage connections, or reverse polarity occurrences\nHigh quality cables Providing premium, labeled short cables and SMD IC hook clips, engineered for easy and secure attachment to small chips\nPower supply for the most common voltages Support for working directly with 5v, 3.3v, 2.5v and 1.8v. So you won’t need an external circuit to hack a 1.8v chip\nPower supply capabilities allow for the connection of more power-hungry devices (~300ma)\nBus Pirate v3 compatible Fully compatible with both the official Bus Pirate firmware and bootloader, as well as versions supported by the Bus Pirate community\nWe care about the environment Designed for easy DIY repairs and modifications: Large components (when possible) and ample spacing between them allow for hassle-free fixes.\nNo need for a microscope or expensive tools - a soldering iron and a pair of tweezers are all you need\nWe strive to use the best environmentally friendly materials whenever possible and cost-effective\nOpen Source and Open Hardware In all our work, we use the MIT license, which allows you to use, modify, and distribute our work for any purpose, even commercially\nFlashrom, OpenOCD and AVRDude support We will ensure it works seamlessly with software like AVRDude, OpenOCD and Flashrom which are widely used, well-known, and stable tools in the hardware hacking scene\nWe also create new hardware hacking tools and enhance support for existing ones\nArtisanal As a small, artisanal creator without the extensive resources of a large company, we dedicate significant manual labor and attention to detail for each individual board\nOur commitment is to quality over quantity, and as a result, the product may be priced higher\nPatience is appreciated as human errors and occasional bugs are an inherent part of this bespoke process\nBuzzpirat is not intended for mass production (limited stock available)\n","categories":"","description":"","excerpt":" Buzzpirat: All-In-One Ruggedized Hardware Hacking tool for learning, …","ref":"/","tags":"","title":"Buzzpirat"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":" If you value what we are building and would like to see it thrive, please consider making a donation or purchasing one of the units. Your support will directly contribute to maintaining the project, acquiring necessary hardware, R+D, developing the website, enhancing mobile applications and so much more\nPayPal Patreon GitHub y3rb1t4 ","categories":"","description":"","excerpt":" If you value what we are building and would like to see it thrive, …","ref":"/donations/","tags":"","title":"Donations"},{"body":"","categories":"","description":"","excerpt":"","ref":"/search/","tags":"","title":"Search Results"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]